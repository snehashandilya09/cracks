{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Returns the required fee to update a TWAP price.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getTwapUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method will not store the price updates on-chain.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime,` but choose to store price updates if `storeUpdatesIfFresh`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// This method will eventually allow the caller to determine whether parsed price feeds should update\n    /// the stored values as well.\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minAllowedPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxAllowedPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @param storeUpdatesIfFresh flag for the parse function to\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesWithConfig(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minAllowedPublishTime,\n        uint64 maxAllowedPublishTime,\n        bool checkUniqueness,\n        bool checkUpdateDataIsMinimal,\n        bool storeUpdatesIfFresh\n    )\n        external\n        payable\n        returns (\n            PythStructs.PriceFeed[] memory priceFeeds,\n            uint64[] memory slots\n        );\n\n    /// @notice Parse time-weighted average price (TWAP) from two consecutive price updates for the given `priceIds`.\n    ///\n    /// This method calculates TWAP between two data points by processing the difference in cumulative price values\n    /// divided by the time period. It requires exactly two updates that contain valid price information\n    /// for all the requested price IDs.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the updateData array.\n    ///\n    /// @dev Reverts if:\n    /// - The transferred fee is not sufficient\n    /// - The updateData is invalid or malformed\n    /// - The updateData array does not contain exactly 2 updates\n    /// - There is no update for any of the given `priceIds`\n    /// - The time ordering between data points is invalid (start time must be before end time)\n    /// @param updateData Array containing exactly two price updates (start and end points for TWAP calculation)\n    /// @param priceIds Array of price ids to calculate TWAP for\n    /// @return twapPriceFeeds Array of TWAP price feeds corresponding to the given `priceIds` (with the same order)\n    function parseTwapPriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds\n    )\n        external\n        payable\n        returns (PythStructs.TwapPriceFeed[] memory twapPriceFeeds);\n\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\n    /// this method will return the first update. This method may store the price updates on-chain, if they\n    /// are more recent than the current stored prices.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdatesUnique(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n\n    /// @dev Emitted when the TWAP price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param startTime Start time of the TWAP.\n    /// @param endTime End time of the TWAP.\n    /// @param twapPrice Price of the TWAP.\n    /// @param twapConf Confidence interval of the TWAP.\n    /// @param downSlotsRatio Down slot ratio of the TWAP.\n    event TwapPriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 startTime,\n        uint64 endTime,\n        int64 twapPrice,\n        uint64 twapConf,\n        uint32 downSlotsRatio\n    );\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n\n    struct TwapPriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Start time of the TWAP\n        uint64 startTime;\n        // End time of the TWAP\n        uint64 endTime;\n        // TWAP price\n        Price twap;\n        // Down slot ratio represents the ratio of price feed updates that were missed or unavailable\n        // during the TWAP period, expressed as a fixed-point number between 0 and 1e6 (100%).\n        // For example:\n        //   - 0 means all price updates were available\n        //   - 500_000 means 50% of updates were missed\n        //   - 1_000_000 means all updates were missed\n        // This can be used to assess the quality/reliability of the TWAP calculation.\n        // Applications should define a maximum acceptable ratio (e.g. 100000 for 10%)\n        // and revert if downSlotsRatio exceeds it.\n        uint32 downSlotsRatio;\n    }\n\n    // Information used to calculate time-weighted average prices (TWAP)\n    struct TwapPriceInfo {\n        // slot 1\n        int128 cumulativePrice;\n        uint128 cumulativeConf;\n        // slot 2\n        uint64 numDownSlots;\n        uint64 publishSlot;\n        uint64 publishTime;\n        uint64 prevPublishTime;\n        // slot 3\n        int32 expo;\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "contracts/core/OracleGadgetImpl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../interfaces/IClearSettle.sol\";\nimport \"../libraries/OracleGadget.sol\";\nimport \"../oracles/OracleAggregator.sol\";\n\n/**\n * @title OracleGadgetImpl\n * @author ClearSettle Team - TriHacker Tournament Finale Module 4\n * @notice Implements IOracleGadget with full oracle price submission and dispute resolution\n * @dev Oracle node submits prices with proofs, watchtowers challenge invalid prices\n *\n * WORKFLOW:\n * 1. Prover submits price + DECO proof + bond → PENDING status\n * 2. Dispute window: watchtower can challenge (commit-reveal to prevent front-run)\n * 3. If no challenge: price → CONFIRMED after window closes\n * 4. If challenged: bisection game begins, one-step verification determines winner\n * 5. Winner receives reward (1.5x multiplier), loser forfeits bond\n */\ncontract OracleGadgetImpl is IOracleGadget {\n    using OracleGadget for *;\n\n    // ============ Events (replicating those from OracleGadget library) ============\n\n    event OraclePriceSubmitted(\n        uint256 indexed oraclePriceId,\n        address indexed prover,\n        uint256 price,\n        uint256 proverBond\n    );\n\n    event ChallengeCommitted(\n        uint256 indexed oraclePriceId,\n        address indexed challenger\n    );\n\n    event ChallengeRevealed(\n        uint256 indexed oraclePriceId,\n        address indexed challenger,\n        bool decision\n    );\n\n    event GameResolved(\n        uint256 indexed gameId,\n        address indexed winner,\n        uint256 reward\n    );\n\n    event PriceConfirmed(\n        uint256 indexed oraclePriceId,\n        uint256 price\n    );\n\n    // ============ Storage ============\n\n    /// @notice Mapping of price ID to submission details\n    mapping(uint256 => OraclePriceSubmission) public submissions;\n\n    /// @notice Mapping of price ID to challenge commit\n    mapping(uint256 => ChallengeCommit) public challenges;\n\n    /// @notice Mapping of price ID to challenge reveal\n    mapping(uint256 => ChallengeReveal) public reveals;\n\n    /// @notice Mapping of game ID to dispute game state\n    mapping(uint256 => DisputeGame) public games;\n\n    /// @notice Mapping of game ID to escrow vault\n    mapping(uint256 => EscrowVault) public escrows;\n\n    /// @notice Current oracle price (after resolution)\n    uint256 public confirmedPrice;\n\n    /// @notice Block when current price was confirmed\n    uint256 public confirmedPriceBlock;\n\n    /// @notice Total number of price submissions\n    uint256 public priceSubmissionCount;\n\n    /// @notice Total number of dispute games\n    uint256 public gameCount;\n\n    /// @notice Price bounds for sanity check\n    uint256 public minAcceptablePrice = 0.01 ether;      // $0.01\n    uint256 public maxAcceptablePrice = 100000 ether;    // $100k\n\n    /// @notice Oracle aggregator for real price verification\n    OracleAggregator public oracleAggregator;\n\n    /// @notice Asset pair for oracle verification (e.g., keccak256(\"ETH/USD\"))\n    bytes32 public pairId;\n\n    event EscrowWithdrawn(uint256 indexed gameId, address indexed beneficiary, uint256 amount);\n\n    // ============ Constructor ============\n\n    /**\n     * @notice Initialize OracleGadgetImpl with oracle aggregator\n     * @param _oracleAggregator Address of deployed OracleAggregator\n     * @param _pairId Asset pair ID (e.g., keccak256(\"ETH/USD\"))\n     */\n    constructor(address _oracleAggregator, bytes32 _pairId) {\n        require(_oracleAggregator != address(0), \"OracleGadgetImpl: Invalid oracle aggregator\");\n        require(_pairId != bytes32(0), \"OracleGadgetImpl: Invalid pair ID\");\n\n        oracleAggregator = OracleAggregator(_oracleAggregator);\n        pairId = _pairId;\n    }\n\n    // ============ Price Submission (Stage 1) ============\n\n    /**\n     * @notice Submit oracle price with DECO proof\n     * @param oraclePrice The price to submit (in ETH per token)\n     * @param proof DECO proof of data authenticity\n     * @param proverBond Bond amount to post\n     *\n     * REQUIRES:\n     * - oraclePrice within sanity bounds\n     * - proof is non-empty (simplified DECO validation)\n     * - msg.value >= proverBond\n     * - proverBond >= MIN_PROVER_BOND\n     */\n    function submitOraclePrice(\n        uint256 oraclePrice,\n        bytes calldata proof,\n        uint256 proverBond\n    )\n        external\n        payable\n        override\n    {\n        // Validate price\n        require(\n            OracleGadget.isPriceSane(oraclePrice, minAcceptablePrice, maxAcceptablePrice),\n            \"OracleGadgetImpl: Price outside acceptable bounds\"\n        );\n\n        // Validate proof\n        require(\n            OracleGadget.validateDECOProof(proof),\n            \"OracleGadgetImpl: Invalid DECO proof\"\n        );\n\n        // Validate bond\n        require(\n            OracleGadget.validateProverBond(proverBond),\n            \"OracleGadgetImpl: Insufficient prover bond\"\n        );\n\n        require(\n            msg.value >= proverBond,\n            \"OracleGadgetImpl: Insufficient funds for bond\"\n        );\n\n        // Create submission\n        uint256 priceId = priceSubmissionCount++;\n        submissions[priceId] = OraclePriceSubmission({\n            oraclePriceId: priceId,\n            price: oraclePrice,\n            prover: msg.sender,\n            proverBond: proverBond,\n            submitBlock: block.number,\n            proverProof: proof,\n            status: OraclePriceStatus.PENDING,\n            challengeCount: 0\n        });\n\n        emit OraclePriceSubmitted(priceId, msg.sender, oraclePrice, proverBond);\n    }\n\n    // ============ Challenge Phase (Stage 2) ============\n\n    /**\n     * @notice Commit to a challenge (prevents front-running)\n     * @param oraclePriceId ID of price to challenge\n     * @param salt Random salt for commit-reveal\n     *\n     * REQUIRES:\n     * - Price is currently PENDING\n     * - Dispute window is still open\n     * - msg.value >= MIN_CHALLENGE_BOND\n     */\n    function commitChallenge(\n        uint256 oraclePriceId,\n        bytes32 salt\n    )\n        external\n        payable\n        override\n    {\n        OraclePriceSubmission storage sub = submissions[oraclePriceId];\n\n        require(\n            sub.status == OraclePriceStatus.PENDING,\n            \"OracleGadgetImpl: Price not pending\"\n        );\n\n        require(\n            block.number <= sub.submitBlock + OracleGadget.DISPUTE_WINDOW,\n            \"OracleGadgetImpl: Dispute window closed\"\n        );\n\n        require(\n            msg.value >= OracleGadget.MIN_CHALLENGE_BOND,\n            \"OracleGadgetImpl: Insufficient challenge bond\"\n        );\n\n        // Create challenge commit\n        bytes32 commitHash = OracleGadget.createChallengeCommit(\n            true,  // Challenger claims price is invalid (true = invalid)\n            salt,\n            msg.sender\n        );\n\n        challenges[oraclePriceId] = ChallengeCommit({\n            challenger: msg.sender,\n            commitHash: commitHash,\n            challengeBond: msg.value,\n            commitBlock: block.number,\n            revealed: false\n        });\n\n        sub.status = OraclePriceStatus.DISPUTED;\n        sub.challengeCount++;\n\n        emit ChallengeCommitted(oraclePriceId, msg.sender);\n    }\n\n    /**\n     * @notice Reveal challenge with evidence\n     * @param oraclePriceId ID of price being challenged\n     * @param decision True if claiming price invalid, false if valid\n     * @param salt Salt from commit phase\n     * @param evidence Bisection proof (simplified: dummy bytes for demo)\n     *\n     * REQUIRES:\n     * - Challenge has been committed\n     * - Reveal window is open\n     * - Commitment hash matches revealed data\n     */\n    function revealChallenge(\n        uint256 oraclePriceId,\n        bool decision,\n        bytes32 salt,\n        bytes calldata evidence\n    )\n        external\n        override\n    {\n        OraclePriceSubmission storage sub = submissions[oraclePriceId];\n        ChallengeCommit storage commit = challenges[oraclePriceId];\n\n        require(\n            sub.status == OraclePriceStatus.DISPUTED,\n            \"OracleGadgetImpl: Price not disputed\"\n        );\n\n        require(\n            !commit.revealed,\n            \"OracleGadgetImpl: Challenge already revealed\"\n        );\n\n        require(\n            OracleGadget.isRevealWindowOpen(commit.commitBlock, block.number),\n            \"OracleGadgetImpl: Reveal window closed\"\n        );\n\n        require(\n            OracleGadget.verifyRevealCommitment(decision, salt, msg.sender, commit.commitHash),\n            \"OracleGadgetImpl: Reveal doesn't match commit\"\n        );\n\n        // Mark as revealed\n        commit.revealed = true;\n        reveals[oraclePriceId] = ChallengeReveal({\n            decision: decision,\n            evidence: evidence,\n            salt: salt,\n            revealBlock: block.number,\n            outcome: BisectionOutcome.GAME_TIMEOUT  // Will be set after dispute resolution\n        });\n\n        // Resolve dispute using REAL oracle verification\n        _resolveDisputeWithOracle(oraclePriceId);\n\n        emit ChallengeRevealed(oraclePriceId, msg.sender, decision);\n    }\n\n    /**\n     * @notice Resolve dispute using real oracle verification\n     * @param oraclePriceId ID of price submission\n     *\n     * REAL IMPLEMENTATION:\n     * - Uses OracleAggregator with 3 oracle sources (Chainlink, Pyth, Uniswap TWAP)\n     * - Byzantine-resistant median calculation\n     * - Handles all 4 adversarial conditions:\n     *   1. 30% incorrect values (median resistant)\n     *   2. Outdated data (staleness checks)\n     *   3. Missing updates (requires 2/3 oracles)\n     *   4. Conflicting values (deviation detection)\n     */\n    function _resolveDisputeWithOracle(uint256 oraclePriceId)\n        internal\n    {\n        OraclePriceSubmission storage sub = submissions[oraclePriceId];\n        ChallengeCommit storage commit = challenges[oraclePriceId];\n\n        // Verify claimed price using real oracle aggregation\n        (bool isValid, string memory reason) = oracleAggregator.verifyClaimedPrice(\n            pairId,\n            sub.price,\n            sub.submitBlock  // Use submit block as claim timestamp\n        );\n\n        uint256 reward = OracleGadget.calculateDisputeReward(\n            sub.proverBond,\n            commit.challengeBond\n        );\n\n        address winner;\n\n        if (isValid) {\n            // Oracle confirms price is valid: prover wins\n            sub.status = OraclePriceStatus.CONFIRMED;\n            confirmedPrice = sub.price;\n            confirmedPriceBlock = block.number;\n            winner = sub.prover;\n        } else {\n            // Oracle rejects price: challenger wins\n            sub.status = OraclePriceStatus.INVALID;\n            winner = commit.challenger;\n        }\n\n        // Create game record\n        uint256 gameId = gameCount++;\n        games[gameId] = DisputeGame({\n            gameId: gameId,\n            oraclePriceId: oraclePriceId,\n            prover: sub.prover,\n            challenger: commit.challenger,\n            traceLength: 1000000,  // Example trace length\n            leftPointer: 0,\n            rightPointer: 1000000,\n            round: 1,\n            status: DisputeGameStatus.RESOLVED,\n            winner: winner\n        });\n\n        // Update reveal outcome based on oracle verification\n        reveals[oraclePriceId].outcome = isValid\n            ? BisectionOutcome.PROVER_VALID\n            : BisectionOutcome.PROVER_INVALID;\n\n        // Emit event for off-chain reward distribution\n        emit GameResolved(gameId, winner, reward);\n    }\n\n    // ============ Price Confirmation ============\n\n    /**\n     * @notice Confirm price after dispute window expires (if no challenge)\n     * @param oraclePriceId ID of price to confirm\n     *\n     * REQUIRES:\n     * - Price is PENDING\n     * - Dispute window has closed\n     * - No challenge has been made\n     */\n    function confirmPrice(uint256 oraclePriceId) external {\n        OraclePriceSubmission storage sub = submissions[oraclePriceId];\n\n        require(\n            sub.status == OraclePriceStatus.PENDING,\n            \"OracleGadgetImpl: Price not pending\"\n        );\n\n        require(\n            block.number > sub.submitBlock + OracleGadget.DISPUTE_WINDOW,\n            \"OracleGadgetImpl: Dispute window still open\"\n        );\n\n        // Confirm price\n        sub.status = OraclePriceStatus.CONFIRMED;\n        confirmedPrice = sub.price;\n        confirmedPriceBlock = block.number;\n\n        // Return bond to prover\n        (bool success, ) = payable(sub.prover).call{value: sub.proverBond}(\"\");\n        require(success, \"OracleGadgetImpl: Bond return failed\");\n\n        emit PriceConfirmed(oraclePriceId, sub.price);\n    }\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Get current confirmed oracle price\n     * @return price The confirmed price (in ETH per token)\n     * @return isResolved True if price is confirmed and no longer disputed\n     */\n    function getConfirmedPrice()\n        external\n        view\n        override\n        returns (uint256 price, bool isResolved)\n    {\n        return (confirmedPrice, confirmedPrice != 0);\n    }\n\n    /**\n     * @notice Get details of a price submission\n     * @param oraclePriceId ID of submission\n     * @return submission The submission details\n     */\n    function getSubmission(uint256 oraclePriceId)\n        external\n        view\n        returns (OraclePriceSubmission memory submission)\n    {\n        return submissions[oraclePriceId];\n    }\n\n    /**\n     * @notice Check if a price is currently confirmed\n     * @param oraclePriceId ID of submission\n     * @return isConfirmed True if price is confirmed\n     */\n    function isPriceConfirmed(uint256 oraclePriceId)\n        external\n        view\n        returns (bool isConfirmed)\n    {\n        return submissions[oraclePriceId].status == OraclePriceStatus.CONFIRMED;\n    }\n\n    /**\n     * @notice Get current price submission count\n     * @return count Number of prices submitted\n     */\n    function getPriceSubmissionCount() external view returns (uint256 count) {\n        return priceSubmissionCount;\n    }\n}\n"
    },
    "contracts/interfaces/IClearSettle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title IClearSettle\n * @author ClearSettle Team - TriHacker Tournament Finale\n * @notice Core interfaces for the ClearSettle Epoch-Based Batch Auction Protocol\n * @dev Implements fair ordering through commit-reveal with batch settlement\n * \n * ARCHITECTURE OVERVIEW:\n * =====================\n * ClearSettle is an adversarial-resilient settlement protocol that processes\n * trades through epoch-based batch auctions. Each epoch has 5 phases:\n * \n * 1. ACCEPTING_COMMITS  - Users submit hashed orders (blind bids)\n * 2. ACCEPTING_REVEALS  - Users reveal their orders with salt\n * 3. SETTLING          - Contract calculates uniform clearing price\n * 4. SAFETY_BUFFER     - Wait period for reorg protection (partial finality)\n * 5. FINALIZED         - Users can withdraw settled funds\n * \n * KEY SECURITY PROPERTIES:\n * - Fair Ordering: Settlement independent of validator ordering (batch execution)\n * - Invariant Enforcement: 5 core invariants verified on every state change\n * - Partial Finality: Multi-block settlement with safety buffer\n * - Oracle Defense: Optimistic assertions with dispute mechanism\n */\n\n/**\n * @notice Epoch lifecycle phases\n * @dev Each epoch progresses through these phases sequentially\n * Transitions are time-bound (block-based) and cannot be skipped\n *\n * AFSM STATES (per Module-1 Section 2.1):\n * - Idle → UNINITIALIZED\n * - Batching → ACCEPTING_COMMITS / ACCEPTING_REVEALS\n * - PreCommitted → SETTLING\n * - InTransition → IN_TRANSITION (VeriSolid augmentation)\n * - Dispute → VOID (or separate DISPUTE state for oracle challenges)\n * - Finalized → FINALIZED\n */\nenum EpochPhase {\n    UNINITIALIZED,      // 0: Default state, epoch not started (Idle)\n    ACCEPTING_COMMITS,  // 1: Users submit commitment hashes (Batching)\n    ACCEPTING_REVEALS,  // 2: Users reveal orders with salt (Batching)\n    SETTLING,           // 3: Batch settlement calculation (PreCommitted)\n    IN_TRANSITION,      // 4: CRITICAL - Locking state for reentrancy protection (InTransition)\n    SAFETY_BUFFER,      // 5: Reorg protection period (partial finality)\n    FINALIZED,          // 6: Settlement complete, withdrawals enabled (Finalized)\n    VOID                // 7: Emergency state - epoch invalidated (invariant violation)\n}\n\n/**\n * @notice Order direction for batch auction\n */\nenum OrderSide {\n    BUY,   // User wants to buy the settlement asset\n    SELL   // User wants to sell the settlement asset\n}\n\n/**\n * @notice Commitment structure stored during commit phase\n * @dev Only hash is stored on-chain to prevent front-running\n * \n * STORAGE OPTIMIZATION:\n * - Using bytes32 for hash (32 bytes)\n * - Using uint40 for timestamp (5 bytes, good until year 36812)\n * - Using uint96 for bond (12 bytes, max ~79 billion ETH)\n * - Packed into single slot where possible\n */\nstruct Commitment {\n    bytes32 hash;           // keccak256(amount, side, salt, sender)\n    uint40 commitBlock;     // Block when commitment was made\n    uint96 bondAmount;      // ETH bond posted (anti-griefing)\n    bool revealed;          // Whether order has been revealed\n    bool slashed;           // Whether bond was slashed (no-reveal penalty)\n}\n\n/**\n * @notice Revealed order ready for batch settlement\n */\nstruct RevealedOrder {\n    address trader;         // Order owner\n    uint256 amount;         // Amount to trade\n    OrderSide side;         // BUY or SELL\n    uint256 limitPrice;     // Maximum price for BUY, minimum for SELL\n    bool executed;          // Whether order was filled in settlement\n}\n\n/**\n * @notice Epoch metadata and state\n */\nstruct EpochData {\n    uint256 epochId;                // Sequential epoch identifier\n    EpochPhase phase;               // Current phase\n    uint256 startBlock;             // Block when epoch started\n    uint256 commitEndBlock;         // Last block for commits\n    uint256 revealEndBlock;         // Last block for reveals\n    uint256 settleBlock;            // Block when settlement occurred\n    uint256 safetyEndBlock;         // Block when safety buffer ends\n    uint256 clearingPrice;          // Uniform clearing price (set during SETTLING)\n    uint256 totalBuyVolume;         // Total buy orders (revealed)\n    uint256 totalSellVolume;        // Total sell orders (revealed)\n    uint256 matchedVolume;          // Volume that was matched\n    bool disputed;                  // Whether settlement is under dispute\n}\n\n/**\n * @notice Settlement result for a specific user in an epoch\n */\nstruct SettlementResult {\n    uint256 tokensReceived;         // Tokens user receives\n    uint256 tokensPaid;             // Tokens user paid\n    uint256 bondReturned;           // Bond amount returned\n    bool claimed;                   // Whether user claimed their settlement\n}\n\n/**\n * @notice Oracle assertion for disputed settlements\n * @dev Used in optimistic oracle defense mechanism\n *\n * TODO: For production, integrate with Chainlink or UMA oracle\n * Currently uses internal assertion/dispute for hackathon demo\n */\nstruct OracleAssertion {\n    address asserter;               // Who made the assertion\n    bytes32 assertionHash;          // Hash of asserted data\n    uint256 bond;                   // Bond posted by asserter\n    uint256 assertionBlock;         // When assertion was made\n    uint256 disputeDeadline;        // Last block to dispute\n    bool disputed;                  // Whether challenged\n    bool resolved;                  // Whether finalized\n    bool truthful;                  // Outcome (if resolved)\n}\n\n// ============ MODULE 2: FAIR ORDERING & MEV RESISTANCE ============\n\n/**\n * @notice Validator timestamp for reception log (Aequitas Stage I)\n * @dev Used to track when each validator received a transaction\n */\nstruct ValidatorTimestamp {\n    address validator;              // Validator address\n    uint256 timestamp;              // When they received the tx (block number)\n}\n\n/**\n * @notice Reception log entry for a transaction\n * @dev Stores all validator timestamps for ordering fairness\n */\nstruct ReceptionLog {\n    bytes32 txHash;                 // Transaction hash\n    ValidatorTimestamp[] timestamps;// Timestamps from all validators\n    bool finalized;                 // Whether ordering is finalized\n}\n\n/**\n * @notice Dependency graph edge for fair ordering\n * @dev Used in Aequitas algorithm (Stage II)\n */\nstruct DependencyEdge {\n    bytes32 fromTx;                 // Source transaction\n    bytes32 toTx;                   // Target transaction\n    uint256 supportCount;           // Number of validators who saw fromTx first\n    bool enforced;                  // Whether edge is above fairness threshold\n}\n\n/**\n * @notice Strongly Connected Component (SCC) - Atomic Batch\n * @dev Transactions in same SCC are \"simultaneous\" (partial finality)\n */\nstruct AtomicBatch {\n    bytes32[] transactions;         // List of tx hashes in this SCC\n    uint256 batchIndex;             // Order in final sequence\n    bool executed;                  // Whether batch has been executed\n}\n\n/**\n * @notice Counterfactual benchmark for FCA fairness\n * @dev Stores oracle price and expected value per user\n */\nstruct CounterfactualBenchmark {\n    uint256 oraclePrice;            // Median oracle price for reference\n    address user;                   // User being benchmarked\n    uint256 expectedTokens;         // Tokens they'd get trading alone at oracle price\n    uint256 expectedCost;           // Cost they'd pay at oracle price\n}\n\n/**\n * @notice State for Tarjan's SCC algorithm\n * @dev Used internally for finding strongly connected components\n *\n * TARJAN'S ALGORITHM STATE:\n * - disc[]: Discovery time of each node\n * - low[]: Lowest discovery time reachable from subtree\n * - onStack[]: Whether node is currently on DFS stack\n * - stack[]: DFS stack for backtracking\n * - sccId[]: Which SCC each node belongs to\n * - sccs[][]: Collection of SCCs found\n */\nstruct TarjanState {\n    bytes32[] txHashes;             // Transaction hashes being processed\n    uint256 n;                      // Number of transactions\n    uint256 time;                   // Global time counter for discovery\n    uint256 sccCount;               // Number of SCCs found\n\n    // Tarjan algorithm arrays\n    uint256[] disc;                 // Discovery time per node\n    uint256[] low;                  // Lowlink value per node\n    bool[] onStack;                 // Stack membership per node\n    uint256[] stack;                // DFS stack\n    uint256 stackTop;               // Stack pointer\n    uint256[] sccId;                // SCC id per node\n\n    // Graph structure\n    uint256[][] adj;                // Adjacency list\n    uint256[][] sccs;               // Found SCCs (array of node indices)\n}\n\n/**\n * @title IClearSettleCore\n * @notice Main interface for ClearSettle protocol interactions\n */\ninterface IClearSettleCore {\n    // ============ Events ============\n    \n    /// @notice Emitted when a new epoch starts\n    event EpochStarted(uint256 indexed epochId, uint256 startBlock, uint256 commitEndBlock);\n    \n    /// @notice Emitted when user commits to an order\n    event OrderCommitted(uint256 indexed epochId, address indexed trader, bytes32 commitmentHash);\n    \n    /// @notice Emitted when user reveals their order\n    event OrderRevealed(uint256 indexed epochId, address indexed trader, uint256 amount, OrderSide side);\n    \n    /// @notice Emitted when epoch settles\n    event EpochSettled(uint256 indexed epochId, uint256 clearingPrice, uint256 matchedVolume);\n    \n    /// @notice Emitted when user claims settlement\n    event SettlementClaimed(uint256 indexed epochId, address indexed trader, uint256 tokensReceived);\n    \n    /// @notice Emitted when bond is slashed (no-reveal)\n    event BondSlashed(uint256 indexed epochId, address indexed trader, uint256 amount);\n    \n    /// @notice Emitted when settlement is disputed\n    event SettlementDisputed(uint256 indexed epochId, address indexed disputer);\n    \n    /// @notice Emitted when invariant is checked\n    event InvariantChecked(string invariantName, bool passed);\n    \n    /// @notice Emitted on emergency void\n    event EpochVoided(uint256 indexed epochId, string reason);\n\n    // ============ Core Functions ============\n    \n    /**\n     * @notice Commit to an order (Phase 1)\n     * @param commitmentHash keccak256(amount, side, salt, msg.sender)\n     * @dev Requires ETH bond to prevent griefing\n     * \n     * SECURITY: Hash hides order details from validators/MEV searchers\n     * until reveal phase, ensuring fair ordering\n     */\n    function commitOrder(bytes32 commitmentHash) external payable;\n    \n    /**\n     * @notice Reveal a committed order (Phase 2)\n     * @param amount Order amount\n     * @param side BUY or SELL\n     * @param limitPrice Price limit\n     * @param salt Random value used in commitment\n     * @dev Must match previously committed hash\n     * \n     * SECURITY: Verifies hash matches, adds to batch for settlement\n     * Bond returned on successful reveal\n     */\n    function revealOrder(\n        uint256 amount,\n        OrderSide side,\n        uint256 limitPrice,\n        bytes32 salt\n    ) external;\n    \n    /**\n     * @notice Trigger epoch settlement (Phase 3)\n     * @dev Can be called by anyone after reveal phase ends\n     * Calculates uniform clearing price and matches orders\n     * \n     * INVARIANTS CHECKED:\n     * 1. Conservation of Value\n     * 2. Solvency\n     * 3. Single Execution (idempotency)\n     */\n    function settleEpoch() external;\n    \n    /**\n     * @notice Claim settlement results (Phase 5)\n     * @param epochId Epoch to claim from\n     * @dev Only available after safety buffer period\n     * \n     * SECURITY: Safety buffer prevents reorg-snipe attacks\n     */\n    function claimSettlement(uint256 epochId) external;\n    \n    /**\n     * @notice Force transition to next epoch (Liveness guarantee)\n     * @dev Can be called if current epoch is stuck\n     * Implements escape hatch for locked funds\n     */\n    function forceAdvanceEpoch() external;\n\n    // ============ View Functions ============\n    \n    function getCurrentEpoch() external view returns (uint256);\n    function getEpochData(uint256 epochId) external view returns (EpochData memory);\n    function getCommitment(uint256 epochId, address trader) external view returns (Commitment memory);\n    function getSettlementResult(uint256 epochId, address trader) external view returns (SettlementResult memory);\n    function getCurrentPhase() external view returns (EpochPhase);\n}\n\n/**\n * @title IClearSettleOracle\n * @notice Interface for oracle defense mechanism\n * @dev Handles disputed settlements through optimistic assertions\n * \n * TODO: For production deployment:\n * - Integrate with Chainlink Data Feeds for price verification\n * - Consider UMA Optimistic Oracle for complex disputes\n * - Add TWAP checks for manipulation resistance\n */\ninterface IClearSettleOracle {\n    /**\n     * @notice Assert a settlement result\n     * @param epochId Epoch being asserted\n     * @param clearingPrice Asserted clearing price\n     * @param matchedVolume Asserted matched volume\n     * @dev Requires bond, opens dispute window\n     */\n    function assertSettlement(\n        uint256 epochId,\n        uint256 clearingPrice,\n        uint256 matchedVolume\n    ) external payable;\n    \n    /**\n     * @notice Dispute an assertion\n     * @param epochId Epoch being disputed\n     * @param evidence Supporting data for dispute\n     * @dev Requires matching bond, triggers resolution\n     */\n    function disputeSettlement(\n        uint256 epochId,\n        bytes calldata evidence\n    ) external payable;\n    \n    /**\n     * @notice Resolve a dispute\n     * @param epochId Epoch to resolve\n     * @dev Called after dispute window or by arbiter\n     */\n    function resolveDispute(uint256 epochId) external;\n}\n\n/**\n * @title IClearSettleSafety\n * @notice Interface for invariant enforcement\n * @dev All invariants must pass for state transitions\n */\ninterface IClearSettleSafety {\n    /**\n     * @notice Check all protocol invariants\n     * @return allPassed True if all invariants hold\n     * @return failedInvariant Name of first failed invariant (empty if all pass)\n     */\n    function checkAllInvariants() external view returns (bool allPassed, string memory failedInvariant);\n\n    /**\n     * @notice Trigger emergency shutdown if invariant violated\n     * @param reason Description of violation\n     */\n    function emergencyVoid(string calldata reason) external;\n}\n\n/**\n * @notice Module-3: Checkpoint for finality gadget\n * @dev Represents a position in the finalized chain\n */\nstruct Checkpoint {\n    bytes32 chainRoot;              // Block being voted on\n    uint256 height;                 // Checkpoint height (block_number / checkpoint_interval)\n    uint256 epoch;                  // Current view/round number\n}\n\n/**\n * @notice Module-3: Vote for checkpoint (Casper FFG style)\n * @dev Contains both source (previous justified) and target (proposed) checkpoint\n */\nstruct Vote {\n    address validator;              // Validator identity\n    Checkpoint source;              // Last justified checkpoint validator has seen\n    Checkpoint target;              // Proposed checkpoint being voted for\n    bytes signature;                // ECDSA signature over vote\n}\n\n/**\n * @notice Module-3: Global protocol state for finality gadget\n * @dev Tracks available chain, justified checkpoints, and finalized checkpoints\n */\nstruct FinalizationState {\n    bytes32 availableChainHead;     // chAva: Head of available chain (liveness)\n    Checkpoint justifiedCheckpoint; // chJust: Highest justified checkpoint (partial finality)\n    Checkpoint finalizedCheckpoint; // chFin: Highest finalized checkpoint (settlement)\n    uint256 totalValidatorStake;    // Total stake of all validators\n    uint256 currentEpoch;           // Current view/round number\n}\n\n/**\n * @title ISettlementGadget\n * @notice Finality gadget implementing Casper FFG + GRANDPA concepts\n * @dev Module-3: Partial Finality & Liveness Protocol\n */\ninterface ISettlementGadget {\n    // ============ Events ============\n\n    /// @notice Emitted when checkpoint is justified (Partial Finality)\n    event CheckpointJustified(Checkpoint indexed checkpoint, uint256 totalVotingWeight);\n\n    /// @notice Emitted when checkpoint is finalized (Settlement Complete)\n    event CheckpointFinalized(Checkpoint indexed checkpoint, bytes32 chainRoot);\n\n    /// @notice Emitted when validator equivocates (double vote)\n    event ValidatorSlashed(address indexed validator, string reason);\n\n    /// @notice Emitted when surround vote is detected\n    event SurroundVoteDetected(address indexed validator, Checkpoint vote1Source, Checkpoint vote1Target, Checkpoint vote2Source, Checkpoint vote2Target);\n\n    // ============ Core Functions ============\n\n    /**\n     * @notice Submit a vote for a checkpoint\n     * @param vote Vote containing source, target, validator, and signature\n     * @dev Validates signature and checks for slashing conditions\n     */\n    function submitVote(Vote calldata vote) external;\n\n    /**\n     * @notice Process votes and update justification/finalization state\n     * @param votes Array of votes to process\n     * @dev Updates justified and finalized checkpoints based on 2/3+ consensus\n     */\n    function processVotes(Vote[] calldata votes) external;\n\n    /**\n     * @notice Submit evidence of a slashing violation\n     * @param vote1 First vote by validator\n     * @param vote2 Second vote by same validator\n     * @dev Detects double votes or surround votes; triggers slashing\n     */\n    function submitSlashingEvidence(Vote calldata vote1, Vote calldata vote2) external;\n\n    /**\n     * @notice Get the current finalization state\n     * @return state The global finalization state\n     */\n    function getFinalizationState() external view returns (FinalizationState memory);\n\n    /**\n     * @notice Check if a checkpoint is justified\n     * @param checkpoint Checkpoint to check\n     * @return isJustified True if checkpoint has > 2/3 votes\n     */\n    function isCheckpointJustified(Checkpoint calldata checkpoint) external view returns (bool);\n\n    /**\n     * @notice Check if a checkpoint is finalized\n     * @param checkpoint Checkpoint to check\n     * @return isFinalized True if checkpoint is finalized\n     */\n    function isCheckpointFinalized(Checkpoint calldata checkpoint) external view returns (bool);\n\n    /**\n     * @notice Recover from network partition (liveness)\n     * @dev Allows finalization of highest justified ancestor when < 2/3 votes available\n     */\n    function recoverFromPartition() external;\n}\n\n// ============ MODULE-4: ORACLE MANIPULATION RESISTANCE & DISPUTE RESOLUTION ============\n\n/**\n * @title IOracleGadget\n * @notice Oracle-based price feed with dispute resolution\n * @dev Implements Optimistic Oracle Settlement Engine (OOSE) with:\n *      - DECO protocol for data provenance (TLS authenticity)\n *      - Specular dispute resolution (bisection game + one-step proofs)\n *      - Economic security (escrow bonds + commit-reveal)\n */\ninterface IOracleGadget {\n    /**\n     * @notice Submit oracle price with cryptographic proof\n     * @param oraclePrice The submitted price (in ETH per token)\n     * @param proof DECO proof of data authenticity from TLS session\n     * @param proverBond Bond posted by prover (in ETH)\n     */\n    function submitOraclePrice(\n        uint256 oraclePrice,\n        bytes calldata proof,\n        uint256 proverBond\n    ) external payable;\n\n    /**\n     * @notice Challenge submitted oracle price\n     * @param oraclePriceId Identifier of price submission to challenge\n     * @param salt Random value for commit-reveal scheme\n     */\n    function commitChallenge(\n        uint256 oraclePriceId,\n        bytes32 salt\n    ) external payable;\n\n    /**\n     * @notice Reveal challenge decision and evidence\n     * @param oraclePriceId Identifier of price to challenge\n     * @param decision True if claiming price is invalid, false if valid\n     * @param salt Salt used in commit phase\n     * @param evidence Bisection proof demonstrating invalid execution\n     */\n    function revealChallenge(\n        uint256 oraclePriceId,\n        bool decision,\n        bytes32 salt,\n        bytes calldata evidence\n    ) external;\n\n    /**\n     * @notice Get current oracle price (after dispute resolution window)\n     * @return price The confirmed price in ETH per token\n     * @return isResolved Whether price is confirmed (dispute window closed)\n     */\n    function getConfirmedPrice() external view returns (uint256 price, bool isResolved);\n}\n\n/**\n * @notice Oracle price submission with cryptographic proof\n */\nstruct OraclePriceSubmission {\n    uint256 oraclePriceId;          // Sequential submission identifier\n    uint256 price;                  // Price in ETH per token\n    address prover;                 // Validator/oracle node that submitted price\n    uint256 proverBond;             // Bond posted by prover (in ETH)\n    uint256 submitBlock;            // Block when price was submitted\n    bytes proverProof;              // DECO proof of TLS authenticity\n    OraclePriceStatus status;       // Current status (Pending, Confirmed, Disputed)\n    uint256 challengeCount;         // Number of challenges\n}\n\n/**\n * @notice Status of oracle price submission\n */\nenum OraclePriceStatus {\n    PENDING,        // 0: Awaiting dispute window\n    CONFIRMED,      // 1: Survived dispute window, price locked\n    DISPUTED,       // 2: Under active dispute\n    INVALID,        // 3: Dispute resolved, price invalid\n    RESOLVED        // 4: Dispute resolved, prover invalid\n}\n\n/**\n * @notice Challenge to oracle price (commit phase)\n */\nstruct ChallengeCommit {\n    address challenger;             // Wallet address of challenger\n    bytes32 commitHash;             // H(decision || salt || challenger)\n    uint256 challengeBond;          // Bond posted by challenger (in ETH)\n    uint256 commitBlock;            // Block when challenge was committed\n    bool revealed;                  // Whether reveal has occurred\n}\n\n/**\n * @notice Revealed challenge with evidence\n */\nstruct ChallengeReveal {\n    bool decision;                  // True if claiming price invalid, false if valid\n    bytes evidence;                 // Bisection proof or one-step proof\n    bytes32 salt;                   // Random salt from commit phase\n    uint256 revealBlock;            // Block when challenge was revealed\n    BisectionOutcome outcome;       // Result of dispute resolution\n}\n\n/**\n * @notice Bisection game state for dispute resolution\n */\nstruct DisputeGame {\n    uint256 gameId;                 // Unique game identifier\n    uint256 oraclePriceId;          // Price submission being disputed\n    address prover;                 // Original price submitter\n    address challenger;             // Challenge initiator\n    uint256 traceLength;            // Total number of execution steps\n    uint256 leftPointer;            // Current bisection left boundary\n    uint256 rightPointer;           // Current bisection right boundary\n    uint256 round;                  // Current bisection round\n    DisputeGameStatus status;       // Game state\n    address winner;                 // Winner after game resolution\n}\n\n/**\n * @notice Status of dispute game\n */\nenum DisputeGameStatus {\n    ACTIVE,         // 0: Bisection game ongoing\n    CONVERGED,      // 1: Bisection has converged to single step\n    RESOLVED,       // 2: Winner determined\n    TIMEOUT         // 3: Timeout due to inactivity\n}\n\n/**\n * @notice Result of bisection game\n */\nenum BisectionOutcome {\n    PROVER_VALID,   // 0: Price is valid, prover receives reward\n    PROVER_INVALID, // 1: Price is invalid, challenger receives reward\n    GAME_TIMEOUT    // 2: Game timed out, challenger wins by default\n}\n\n/**\n * @notice Escrow vault for bonds during dispute\n */\nstruct EscrowVault {\n    uint256 totalLocked;            // Total value locked in escrow\n    uint256 unlockBlock;            // Block when escrow becomes withdrawable\n    address beneficiary;            // Address that receives escrow\n    bool withdrawn;                 // Whether escrow has been withdrawn\n}\n\n/**\n * @notice One-step proof for EVM opcode execution\n */\nstruct OneStepProof {\n    uint256 stepIndex;              // Index of step in execution trace\n    bytes32 beforeState;            // EVM state before opcode execution\n    bytes32 afterState;             // EVM state after opcode execution\n    uint256 gasCost;                // Gas consumed by opcode\n    bytes opcode;                   // The opcode being verified\n}\n\n// ============ MODULE-5: ATTACK MODEL & REORG SAFETY ENGINE ============\n\n/**\n * @notice Unique identifier for transaction idempotence\n * @dev Nullifier = keccak256(Sender || Nonce || PayloadHash)\n * CRITICAL: Does NOT include BlockNumber, so survives reorgs\n */\ntype Nullifier is bytes32;\n\n/**\n * @notice Finality status for settlement batches\n * @dev Three shades of finality:\n *      - PENDING: Just submitted, vulnerable to shallow reorgs\n *      - LOGGED: Included in L1, but still within reorg window\n *      - CHECKPOINTED: After LOOKBACK_DISTANCE, immutable\n */\nenum FinalityStatus {\n    PENDING,        // 0: In mempool, not yet in block\n    LOGGED,         // 1: Included in L1, vulnerable to shallow reorg\n    CHECKPOINTED    // 2: Passed LOOKBACK_DISTANCE, immutable (state finality)\n}\n\n/**\n * @notice Settlement batch for reorg-safe settlement\n * @dev Contains array of nullifiers to track idempotence\n * Each batch is atomic: all transactions finalize together or none\n */\nstruct SettlementBatch {\n    uint256 batchId;                // Sequential batch identifier\n    bytes32 stateRoot;              // Hash of batch state (for ordering verification)\n    bytes32[] transactionNullifiers; // Array of transaction nullifiers\n    uint256 l1BlockNumber;          // Block where batch was included on L1\n    FinalityStatus status;          // Current finality status\n}\n\n/**\n * @title ISafetyEngine\n * @notice Reorg-safe settlement and idempotence enforcement\n * @dev Module-5: Attack Model & Reorg Safety Engine\n *\n * Protects against:\n * 1. Shallow reorgs (≤64 blocks) - Lookback window\n * 2. Double-spending via replays - Nullifier tracking\n * 3. Time-Bandit attacks - Economic security\n * 4. Deep reorg forks - Ancestry verification\n */\ninterface ISafetyEngine {\n    // ============ Events ============\n\n    /// @notice Emitted when batch enters LOGGED status\n    event BatchLogged(uint256 indexed batchId, bytes32 stateRoot, uint256 l1BlockNumber);\n\n    /// @notice Emitted when batch becomes CHECKPOINTED (immutable)\n    event BatchCheckpointed(uint256 indexed batchId, uint256 finalityBlock);\n\n    /// @notice Emitted when deep reorg detected\n    event DeepReorgDetected(uint256 storedHeight, bytes32 storedHash, bytes32 actualHash);\n\n    /// @notice Emitted when double-settlement attempt detected\n    event DoubleSettlementAttempt(bytes32 indexed nullifier, uint256 currentBatch, uint256 previousBatch);\n\n    /// @notice Emitted when nullifier reclaimed after orphaned batch\n    event NullifierReclaimed(bytes32 indexed nullifier, uint256 batchId);\n\n    // ============ Core Functions ============\n\n    /**\n     * @notice Log batch on L1 (first finality shade)\n     * @param batchId Batch identifier\n     * @param stateRoot Hash of batch state\n     * @return success True if logged successfully\n     */\n    function logBatch(uint256 batchId, bytes32 stateRoot) external returns (bool success);\n\n    /**\n     * @notice Finalize batch after LOOKBACK_DISTANCE blocks\n     * @param batchId Batch to finalize\n     * @param parentHash Hash of previous finalized batch (ancestry check)\n     * @dev Requires batch to be at least LOOKBACK_DISTANCE old\n     * CRITICAL: Verifies parent ancestry to detect forks\n     */\n    function finalizeBatch(uint256 batchId, bytes32 parentHash) external;\n\n    /**\n     * @notice Verify batch transactions have no replays\n     * @param batchId Batch being verified\n     * @param nullifiers Array of transaction nullifiers\n     * @return isIdempotent True if no double-spending detected\n     */\n    function verifyIdempotence(uint256 batchId, bytes32[] calldata nullifiers) external view returns (bool isIdempotent);\n\n    /**\n     * @notice Detect deep reorg by checking old blockhash\n     * @param expectedHeight Block height of stored chain tip\n     * @param expectedHash Hash of stored chain tip\n     * @return hasReorged True if deep reorg detected\n     */\n    function detectDeepReorg(uint256 expectedHeight, bytes32 expectedHash) external view returns (bool hasReorged);\n\n    /**\n     * @notice Reclaim nullifier after shallow reorg orphaned previous batch\n     * @param nullifier Transaction nullifier to reclaim\n     * @param previousBatchId ID of batch that was orphaned\n     * @dev Only allowed if previous batch is not CHECKPOINTED\n     */\n    function reclaimNullifier(bytes32 nullifier, uint256 previousBatchId) external;\n\n    // ============ View Functions ============\n\n    /**\n     * @notice Check if batch is finalized (immutable)\n     * @param batchId Batch to check\n     * @return isCheckpointed True if batch status is CHECKPOINTED\n     */\n    function isBatchFinalized(uint256 batchId) external view returns (bool isCheckpointed);\n\n    /**\n     * @notice Get finality status of batch\n     * @param batchId Batch identifier\n     * @return status Current FinalityStatus\n     */\n    function getBatchStatus(uint256 batchId) external view returns (FinalityStatus status);\n\n    /**\n     * @notice Get nullifier consumption status\n     * @param nullifier Transaction nullifier\n     * @return consumedInBatch Batch ID where consumed, or 0 if not consumed\n     */\n    function getNullifierStatus(bytes32 nullifier) external view returns (uint256 consumedInBatch);\n\n    /**\n     * @notice Get highest finalized batch\n     * @return batchId ID of last finalized batch\n     * @return hash Hash of finalized batch\n     */\n    function getLastFinalizedBatch() external view returns (uint256 batchId, bytes32 hash);\n}\n"
    },
    "contracts/libraries/OracleGadget.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"../interfaces/IClearSettle.sol\";\n\n/**\n * @title OracleGadget\n * @author ClearSettle Team - TriHacker Tournament Finale Module 4\n * @notice Implements oracle price feeds with optimistic settlement and dispute resolution\n * @dev Combines DECO (TLS provenance), Specular (bisection game), and economic security\n *\n * MODULE-4: ORACLE MANIPULATION RESISTANCE & DISPUTE RESOLUTION\n * ============================================================\n *\n * This library implements the Optimistic Oracle Settlement Engine (OOSE):\n *\n * 1. PROVER PHASE:\n *    - Prover/oracle node fetches price from TLS-enabled source\n *    - Commits price with cryptographic proof (simplified DECO)\n *    - Posts bond (MIN_PROVER_BOND = 1 ether)\n *\n * 2. DISPUTE WINDOW:\n *    - Price is PENDING for T_DISPUTE blocks\n *    - Watchtower/challengers can initiate dispute\n *    - Commit-reveal scheme prevents front-running challenges\n *\n * 3. BISECTION GAME:\n *    - If disputed, prover and challenger play bisection game\n *    - Game narrows disagreement in log(n) rounds\n *    - Example: 1M step trace → 20 rounds to single step\n *\n * 4. ONE-STEP VERIFICATION:\n *    - When bisection converges, verify single EVM opcode\n *    - On-chain verification of state transition\n *    - Winner takes loser's bond + reward (1.5x)\n *\n * SECURITY PROPERTIES:\n * ===================\n * ✓ Data Integrity: TLS binding prevents data forgery\n * ✓ Commit-Reveal: Prevents front-running of challenges\n * ✓ Economic Incentives: Honest behavior payoff > dishonest behavior payoff\n * ✓ Byzantine Safety: Dispute resolution always produces correct result\n * ✓ Liveness: >1/3 honest nodes can always challenge false prices\n */\nlibrary OracleGadget {\n\n    // ============ Constants ============\n\n    /// @notice Minimum bond required from prover (in wei)\n    uint256 constant MIN_PROVER_BOND = 1 ether;\n\n    /// @notice Minimum bond required from challenger (in wei)\n    uint256 constant MIN_CHALLENGE_BOND = 0.5 ether;\n\n    /// @notice Dispute resolution window (in blocks)\n    uint256 constant DISPUTE_WINDOW = 100;\n\n    /// @notice Commit window for challenges (in blocks)\n    uint256 constant COMMIT_WINDOW = 10;\n\n    /// @notice Reveal window for challenges (in blocks)\n    uint256 constant REVEAL_WINDOW = 20;\n\n    /// @notice Bisection timeout (in blocks) - if no move, challenger wins\n    uint256 constant BISECTION_TIMEOUT = 50;\n\n    /// @notice Maximum bisection rounds (log2 of max trace length)\n    uint256 constant MAX_BISECTION_ROUNDS = 40;\n\n    /// @notice Reward multiplier for winning dispute (in basis points, 1.5x = 15000)\n    uint256 constant REWARD_MULTIPLIER = 15000; // 150% = 1.5x\n\n    // ============ Events ============\n\n    event OraclePriceSubmitted(\n        uint256 indexed oraclePriceId,\n        address indexed prover,\n        uint256 price,\n        uint256 proverBond\n    );\n\n    event ChallengeInitiated(\n        uint256 indexed oraclePriceId,\n        address indexed challenger,\n        uint256 challengeBond\n    );\n\n    event ChallengeRevealedAsInvalid(\n        uint256 indexed oraclePriceId,\n        address indexed challenger\n    );\n\n    event BisectionProgressed(\n        uint256 indexed gameId,\n        uint256 round,\n        uint256 leftPointer,\n        uint256 rightPointer\n    );\n\n    event DisputeResolved(\n        uint256 indexed gameId,\n        address indexed winner,\n        uint256 reward\n    );\n\n    event OraclePriceConfirmed(\n        uint256 indexed oraclePriceId,\n        uint256 price\n    );\n\n    // ============ Stage 1: Prover Submission ============\n\n    /**\n     * @notice Validate prover bond is sufficient\n     * @param bondAmount Bond amount posted by prover\n     * @return isValid True if bond meets minimum requirement\n     *\n     * SECURITY: Prevents low-bond attacks where prover has no skin in game\n     */\n    function validateProverBond(uint256 bondAmount)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        return bondAmount >= MIN_PROVER_BOND;\n    }\n\n    /**\n     * @notice Validate DECO proof format (simplified for hackathon)\n     * @param proof The DECO proof bytes\n     * @return isValid True if proof format is acceptable\n     *\n     * SIMPLIFIED: Real implementation would verify TLS session binding\n     * For demo: just check proof is non-empty\n     */\n    function validateDECOProof(bytes calldata proof)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        // In production: verify cryptographic commitment from TLS session\n        // Simplified: just check proof exists\n        return proof.length > 0;\n    }\n\n    /**\n     * @notice Calculate dispute window closing block\n     * @param submitBlock Block when price was submitted\n     * @return closeBlock Block number when dispute window closes\n     */\n    function getDisputeWindowClose(uint256 submitBlock)\n        internal\n        pure\n        returns (uint256 closeBlock)\n    {\n        return submitBlock + DISPUTE_WINDOW;\n    }\n\n    // ============ Stage 2: Challenge Commit-Reveal ============\n\n    /**\n     * @notice Verify challenger bond is sufficient\n     * @param bondAmount Bond amount posted by challenger\n     * @return isValid True if bond meets minimum requirement\n     */\n    function validateChallengeBond(uint256 bondAmount)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        return bondAmount >= MIN_CHALLENGE_BOND;\n    }\n\n    /**\n     * @notice Create commit hash for challenge (prevents front-running)\n     * @param decision True if claiming price invalid, false if valid\n     * @param salt Random salt for commit-reveal\n     * @param challenger Address of challenger\n     * @return commitHash Hash to be committed on-chain\n     *\n     * FORMULA: H = Keccak256(decision || salt || challenger)\n     * This prevents adversary from seeing decision and front-running with opposite decision\n     */\n    function createChallengeCommit(\n        bool decision,\n        bytes32 salt,\n        address challenger\n    )\n        internal\n        pure\n        returns (bytes32 commitHash)\n    {\n        return keccak256(abi.encode(decision, salt, challenger));\n    }\n\n    /**\n     * @notice Verify challenge reveal matches committed hash\n     * @param decision Revealed decision\n     * @param salt Revealed salt\n     * @param challenger Challenger address\n     * @param commitHash Previously committed hash\n     * @return isValid True if reveal matches commit\n     */\n    function verifyRevealCommitment(\n        bool decision,\n        bytes32 salt,\n        address challenger,\n        bytes32 commitHash\n    )\n        internal\n        pure\n        returns (bool isValid)\n    {\n        bytes32 recomputedHash = createChallengeCommit(decision, salt, challenger);\n        return recomputedHash == commitHash;\n    }\n\n    /**\n     * @notice Check if challenge commit window is still open\n     * @param commitBlock Block when challenge was committed\n     * @param currentBlock Current block number\n     * @return isOpen True if within commit window\n     */\n    function isCommitWindowOpen(uint256 commitBlock, uint256 currentBlock)\n        internal\n        pure\n        returns (bool isOpen)\n    {\n        return currentBlock <= commitBlock + COMMIT_WINDOW;\n    }\n\n    /**\n     * @notice Check if challenge reveal window is still open\n     * @param commitBlock Block when challenge was committed\n     * @param currentBlock Current block number\n     * @return isOpen True if within reveal window\n     */\n    function isRevealWindowOpen(uint256 commitBlock, uint256 currentBlock)\n        internal\n        pure\n        returns (bool isOpen)\n    {\n        uint256 revealStart = commitBlock + COMMIT_WINDOW;\n        uint256 revealEnd = revealStart + REVEAL_WINDOW;\n        return currentBlock > revealStart && currentBlock <= revealEnd;\n    }\n\n    // ============ Stage 3: Bisection Game ============\n\n    /**\n     * @notice Initialize bisection game (binary search for disagreement point)\n     * @param traceLength Total number of execution steps in trace\n     * @return gameId Identifier for new game\n     *\n     * ALGORITHM: Narrow down disagreement to single step\n     * - Start: [0, traceLength)\n     * - Each round: check middle point, narrow range\n     * - Convergence: ~log2(traceLength) rounds\n     * - Example: 1M steps → ceil(log2(1M)) = 20 rounds\n     */\n    function initializeBisectionGame(uint256 traceLength)\n        internal\n        pure\n        returns (uint256 gameId)\n    {\n        // Game ID would be assigned by contract\n        // For pure function: just validate trace length is reasonable\n        require(traceLength > 0, \"OracleGadget: Invalid trace length\");\n        require(traceLength <= 2 ** MAX_BISECTION_ROUNDS, \"OracleGadget: Trace too long\");\n        return traceLength; // Simplified return\n    }\n\n    /**\n     * @notice Compute next bisection midpoint\n     * @param leftPointer Current left boundary\n     * @param rightPointer Current right boundary\n     * @return midpoint Midpoint between boundaries (next point to check)\n     *\n     * FORMULA: midpoint = (left + right) / 2\n     * Parties alternate moves: prover claims midpoint is valid, challenger disputes\n     */\n    function computeBisectionMidpoint(\n        uint256 leftPointer,\n        uint256 rightPointer\n    )\n        internal\n        pure\n        returns (uint256 midpoint)\n    {\n        return (leftPointer + rightPointer) / 2;\n    }\n\n    /**\n     * @notice Calculate number of rounds needed for convergence\n     * @param traceLength Length of execution trace\n     * @return rounds Number of bisection rounds needed\n     *\n     * FORMULA: rounds = ceil(log2(traceLength))\n     * For efficiency: maximum 40 rounds (handles 2^40 steps)\n     */\n    function calculateBisectionRounds(uint256 traceLength)\n        internal\n        pure\n        returns (uint256 rounds)\n    {\n        if (traceLength <= 1) return 0;\n\n        rounds = 0;\n        uint256 n = traceLength - 1;\n        while (n > 0) {\n            rounds++;\n            n = n / 2;\n        }\n\n        return rounds;\n    }\n\n    /**\n     * @notice Check if bisection game has converged\n     * @param leftPointer Current left boundary\n     * @param rightPointer Current right boundary\n     * @return hasConverged True if game has narrowed to single step\n     *\n     * CONVERGENCE: left + 1 >= right means only one step remains\n     */\n    function hasBisectionConverged(\n        uint256 leftPointer,\n        uint256 rightPointer\n    )\n        internal\n        pure\n        returns (bool hasConverged)\n    {\n        return leftPointer + 1 >= rightPointer;\n    }\n\n    /**\n     * @notice Narrow bisection range based on disagreement report\n     * @param leftPointer Current left boundary\n     * @param rightPointer Current right boundary\n     * @param disagreementAt Reported point of disagreement\n     * @param moveLeft True if disagreement is on left side of check point\n     * @return newLeft New left boundary\n     * @return newRight New right boundary\n     *\n     * LOGIC:\n     * - If prover says midpoint[m] is valid but challenger says invalid\n     * - Challenger reveals which half has disagreement\n     * - Range narrows by half each round\n     */\n    function narrowBisectionRange(\n        uint256 leftPointer,\n        uint256 rightPointer,\n        uint256 disagreementAt,\n        bool moveLeft\n    )\n        internal\n        pure\n        returns (uint256 newLeft, uint256 newRight)\n    {\n        require(disagreementAt > leftPointer && disagreementAt < rightPointer,\n                \"OracleGadget: Invalid disagreement point\");\n\n        if (moveLeft) {\n            // Disagreement is on left side\n            newLeft = leftPointer;\n            newRight = disagreementAt;\n        } else {\n            // Disagreement is on right side\n            newLeft = disagreementAt;\n            newRight = rightPointer;\n        }\n\n        return (newLeft, newRight);\n    }\n\n    // ============ Stage 4: One-Step Verification ============\n\n    /**\n     * @notice Verify a single EVM opcode execution\n     * @param beforeState EVM state before opcode\n     * @param afterState EVM state after opcode\n     * @param opcode The opcode being verified\n     * @return isValid True if state transition is correct for opcode\n     *\n     * ONE-STEP PROOF VERIFICATION:\n     * On-chain, verify single instruction execution\n     * Opcode examples: ADD, MSTORE, RETURN, etc.\n     *\n     * For hackathon: simplified verification of a few key opcodes\n     * Production: full EVM opcode interpreter\n     */\n    function verifyOneStepProof(\n        bytes32 beforeState,\n        bytes32 afterState,\n        bytes calldata opcode\n    )\n        internal\n        pure\n        returns (bool isValid)\n    {\n        // Simplified: just verify both states are non-empty\n        // Production implementation would:\n        // 1. Decode EVM state (stack, memory, PC, gas, storage root)\n        // 2. Execute opcode on beforeState\n        // 3. Verify result matches afterState\n\n        require(beforeState != bytes32(0), \"OracleGadget: Invalid before state\");\n        require(afterState != bytes32(0), \"OracleGadget: Invalid after state\");\n        require(opcode.length > 0, \"OracleGadget: Invalid opcode\");\n\n        // In production: emulate the actual opcode\n        // For demo: states must be different (transaction occurred)\n        return beforeState != afterState;\n    }\n\n    // ============ Stage 5: Reward Distribution ============\n\n    /**\n     * @notice Calculate reward for dispute winner\n     * @param proverBond Bond posted by prover\n     * @param challengerBond Bond posted by challenger\n     * @return reward Total reward (1.5x multiplier on combined bonds)\n     *\n     * FORMULA: R = 1.5 × (D_P + D_C)\n     * Where D_P = prover bond, D_C = challenger bond\n     *\n     * Example:\n     * - Prover bond: 1 ether\n     * - Challenger bond: 0.5 ether\n     * - Total: 1.5 ether\n     * - Reward: 1.5 × 1.5 = 2.25 ether\n     *\n     * Loser: forfeit their bond (0 recovery)\n     * Winner: receives reward from loser's bond + own bond returned\n     */\n    function calculateDisputeReward(\n        uint256 proverBond,\n        uint256 challengerBond\n    )\n        internal\n        pure\n        returns (uint256 reward)\n    {\n        uint256 totalBonds = proverBond + challengerBond;\n        reward = (totalBonds * REWARD_MULTIPLIER) / 10000; // REWARD_MULTIPLIER = 15000 = 1.5x\n        return reward;\n    }\n\n    /**\n     * @notice Determine dispute winner based on one-step verification\n     * @param oneStepProofValid True if one-step proof is valid\n     * @return proverWins True if prover wins dispute\n     *\n     * LOGIC:\n     * - If one-step proof is valid: prover wins (their execution trace is correct)\n     * - If one-step proof is invalid: challenger wins (prover's trace is wrong)\n     */\n    function determineDisputeWinner(bool oneStepProofValid)\n        internal\n        pure\n        returns (bool proverWins)\n    {\n        return oneStepProofValid;\n    }\n\n    // ============ Utility Functions ============\n\n    /**\n     * @notice Check if bisection game has timed out\n     * @param lastMoveBlock Block of last move in bisection game\n     * @param currentBlock Current block number\n     * @return hasTimedOut True if timeout period exceeded\n     *\n     * LIVENESS: If one party stops responding, other party wins by timeout\n     * This prevents indefinite games and ensures liveness\n     */\n    function hasBisectionTimedOut(\n        uint256 lastMoveBlock,\n        uint256 currentBlock\n    )\n        internal\n        pure\n        returns (bool hasTimedOut)\n    {\n        return currentBlock > lastMoveBlock + BISECTION_TIMEOUT;\n    }\n\n    /**\n     * @notice Verify price is reasonable (within expected range)\n     * @param price The price to verify\n     * @param lowerBound Minimum acceptable price\n     * @param upperBound Maximum acceptable price\n     * @return isValid True if price is within bounds\n     *\n     * SANITY CHECK: Prevent clearly invalid prices from flooding protocol\n     */\n    function isPriceSane(\n        uint256 price,\n        uint256 lowerBound,\n        uint256 upperBound\n    )\n        internal\n        pure\n        returns (bool isValid)\n    {\n        return price >= lowerBound && price <= upperBound;\n    }\n}\n"
    },
    "contracts/oracles/ChainlinkOracleAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\n\n/// @title ChainlinkOracleAdapter\n/// @notice Fetches price data from Chainlink decentralized oracle network\n/// @dev Official Sepolia testnet addresses from https://docs.chain.link/data-feeds/price-feeds/addresses\ncontract ChainlinkOracleAdapter {\n\n    struct PriceFeed {\n        AggregatorV3Interface feed;\n        uint8 decimals;\n        string description;\n        uint256 heartbeat; // Max acceptable staleness (seconds)\n    }\n\n    // Feed registry: asset pair => Chainlink aggregator\n    mapping(bytes32 => PriceFeed) public priceFeeds;\n\n    // Chainlink aggregator addresses (Sepolia testnet)\n    // Source: https://docs.chain.link/data-feeds/price-feeds/addresses\n    address public constant ETH_USD_FEED = 0x694AA1769357215DE4FAC081bf1f309aDC325306;\n    address public constant BTC_USD_FEED = 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43;\n    address public constant LINK_USD_FEED = 0xc59E3633BAAC79493d908e63626716e204A45EdF;\n\n    event PriceFeedRegistered(bytes32 indexed pairId, address feedAddress, string description);\n    event PriceFetched(bytes32 indexed pairId, uint256 price, uint256 timestamp, uint80 roundId);\n\n    constructor() {\n        // Register ETH/USD feed\n        _registerFeed(\n            keccak256(\"ETH/USD\"),\n            ETH_USD_FEED,\n            8,\n            \"ETH/USD Chainlink\",\n            3600 // 1 hour max staleness\n        );\n\n        // Register BTC/USD feed\n        _registerFeed(\n            keccak256(\"BTC/USD\"),\n            BTC_USD_FEED,\n            8,\n            \"BTC/USD Chainlink\",\n            3600\n        );\n\n        // Register LINK/USD feed\n        _registerFeed(\n            keccak256(\"LINK/USD\"),\n            LINK_USD_FEED,\n            8,\n            \"LINK/USD Chainlink\",\n            3600\n        );\n    }\n\n    /// @notice Register a new price feed\n    /// @param pairId Identifier for the trading pair\n    /// @param feedAddress Chainlink aggregator address\n    /// @param decimals Number of decimals in the feed\n    /// @param description Human-readable description\n    /// @param heartbeat Maximum acceptable staleness in seconds\n    function _registerFeed(\n        bytes32 pairId,\n        address feedAddress,\n        uint8 decimals,\n        string memory description,\n        uint256 heartbeat\n    ) internal {\n        priceFeeds[pairId] = PriceFeed({\n            feed: AggregatorV3Interface(feedAddress),\n            decimals: decimals,\n            description: description,\n            heartbeat: heartbeat\n        });\n\n        emit PriceFeedRegistered(pairId, feedAddress, description);\n    }\n\n    /// @notice Fetch latest price from Chainlink\n    /// @param pairId Asset pair identifier (e.g., keccak256(\"ETH/USD\"))\n    /// @return price Latest price (normalized to 18 decimals)\n    /// @return timestamp When price was last updated\n    /// @return roundId Chainlink round ID for verification\n    function getLatestPrice(bytes32 pairId)\n        external\n        view\n        returns (\n            uint256 price,\n            uint256 timestamp,\n            uint80 roundId\n        )\n    {\n        PriceFeed memory feed = priceFeeds[pairId];\n        require(address(feed.feed) != address(0), \"ChainlinkAdapter: Feed not registered\");\n\n        (\n            uint80 _roundId,\n            int256 answer,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = feed.feed.latestRoundData();\n\n        // Validation checks\n        require(answer > 0, \"ChainlinkAdapter: Invalid price (non-positive)\");\n        require(updatedAt > 0, \"ChainlinkAdapter: Invalid timestamp\");\n        require(answeredInRound >= _roundId, \"ChainlinkAdapter: Stale price (round mismatch)\");\n\n        // Staleness check\n        require(\n            block.timestamp - updatedAt <= feed.heartbeat,\n            \"ChainlinkAdapter: Price too stale\"\n        );\n\n        // Normalize to 18 decimals (Chainlink uses 8)\n        uint256 normalizedPrice = uint256(answer) * 1e10;\n\n        return (normalizedPrice, updatedAt, _roundId);\n    }\n\n    /// @notice Get price from specific historical round\n    /// @dev Used for dispute resolution (verify historical claim)\n    /// @param pairId Asset pair identifier\n    /// @param roundId Historical round ID to query\n    /// @return price Historical price (normalized to 18 decimals)\n    /// @return timestamp When that round was finalized\n    function getHistoricalPrice(bytes32 pairId, uint80 roundId)\n        external\n        view\n        returns (\n            uint256 price,\n            uint256 timestamp\n        )\n    {\n        PriceFeed memory feed = priceFeeds[pairId];\n        require(address(feed.feed) != address(0), \"ChainlinkAdapter: Feed not registered\");\n\n        (\n            ,\n            int256 answer,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = feed.feed.getRoundData(roundId);\n\n        require(answer > 0, \"ChainlinkAdapter: Invalid historical price\");\n        require(answeredInRound == roundId, \"ChainlinkAdapter: Round not finalized\");\n\n        uint256 normalizedPrice = uint256(answer) * 1e10;\n        return (normalizedPrice, updatedAt);\n    }\n\n    /// @notice Check if a feed is registered\n    /// @param pairId Asset pair to check\n    /// @return True if feed exists\n    function isFeedRegistered(bytes32 pairId) external view returns (bool) {\n        return address(priceFeeds[pairId].feed) != address(0);\n    }\n\n    /// @notice Get feed information\n    /// @param pairId Asset pair to query\n    /// @return feedAddress Chainlink aggregator address\n    /// @return decimals Feed decimals\n    /// @return description Feed description\n    /// @return heartbeat Max staleness in seconds\n    function getFeedInfo(bytes32 pairId)\n        external\n        view\n        returns (\n            address feedAddress,\n            uint8 decimals,\n            string memory description,\n            uint256 heartbeat\n        )\n    {\n        PriceFeed memory feed = priceFeeds[pairId];\n        return (\n            address(feed.feed),\n            feed.decimals,\n            feed.description,\n            feed.heartbeat\n        );\n    }\n}\n"
    },
    "contracts/oracles/DisputeResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./OracleAggregator.sol\";\n\n/// @title DisputeResolver\n/// @notice Handles disputes using real oracle verification\n/// @dev Integrates with OracleAggregator for Byzantine-resistant price verification\ncontract DisputeResolver {\n\n    OracleAggregator public oracleAggregator;\n\n    struct Dispute {\n        bytes32 pairId;\n        uint256 claimedPrice;\n        uint256 claimTimestamp;\n        address challenger;\n        address prover;\n        bool resolved;\n        bool proofValid;\n        uint256 resolutionTime;\n        string resolutionReason;\n    }\n\n    mapping(uint256 => Dispute) public disputes;\n    uint256 public disputeCount;\n\n    // Dispute parameters\n    uint256 public constant DISPUTE_WINDOW = 7 days;    // Time to challenge a claim\n    uint256 public constant RESOLUTION_TIMEOUT = 1 hours; // Time to resolve after challenge\n\n    event DisputeRaised(\n        uint256 indexed disputeId,\n        bytes32 indexed pairId,\n        address indexed challenger,\n        address prover,\n        uint256 claimedPrice\n    );\n\n    event DisputeResolved(\n        uint256 indexed disputeId,\n        bool proofValid,\n        string reason\n    );\n\n    constructor(address _oracleAggregator) {\n        require(_oracleAggregator != address(0), \"DisputeResolver: Invalid oracle aggregator\");\n        oracleAggregator = OracleAggregator(_oracleAggregator);\n    }\n\n    /// @notice Raise a dispute against a price claim\n    /// @dev Anyone can challenge a claim if they believe it's incorrect\n    /// @param pairId Asset pair\n    /// @param claimedPrice Price being disputed\n    /// @param claimTimestamp When the price was claimed\n    /// @param prover Address that made the claim\n    /// @return disputeId ID of the created dispute\n    function raiseDispute(\n        bytes32 pairId,\n        uint256 claimedPrice,\n        uint256 claimTimestamp,\n        address prover\n    ) external returns (uint256 disputeId) {\n        require(prover != address(0), \"DisputeResolver: Invalid prover\");\n        require(claimedPrice > 0, \"DisputeResolver: Invalid price\");\n\n        // Verify claim is within dispute window\n        require(\n            block.timestamp <= claimTimestamp + DISPUTE_WINDOW,\n            \"DisputeResolver: Claim too old to dispute\"\n        );\n\n        disputeId = disputeCount++;\n\n        disputes[disputeId] = Dispute({\n            pairId: pairId,\n            claimedPrice: claimedPrice,\n            claimTimestamp: claimTimestamp,\n            challenger: msg.sender,\n            prover: prover,\n            resolved: false,\n            proofValid: false,\n            resolutionTime: 0,\n            resolutionReason: \"\"\n        });\n\n        emit DisputeRaised(\n            disputeId,\n            pairId,\n            msg.sender,\n            prover,\n            claimedPrice\n        );\n    }\n\n    /// @notice Resolve a dispute using oracle verification\n    /// @dev Uses OracleAggregator to verify the claimed price\n    /// @param disputeId Dispute to resolve\n    function resolveDispute(uint256 disputeId) external {\n        Dispute storage dispute = disputes[disputeId];\n\n        require(!dispute.resolved, \"DisputeResolver: Already resolved\");\n        require(\n            block.timestamp <= dispute.claimTimestamp + DISPUTE_WINDOW + RESOLUTION_TIMEOUT,\n            \"DisputeResolver: Resolution timeout\"\n        );\n\n        // Use OracleAggregator to verify the claimed price\n        (bool isValid, string memory reason) = oracleAggregator.verifyClaimedPrice(\n            dispute.pairId,\n            dispute.claimedPrice,\n            dispute.claimTimestamp\n        );\n\n        dispute.resolved = true;\n        dispute.proofValid = isValid;\n        dispute.resolutionTime = block.timestamp;\n        dispute.resolutionReason = reason;\n\n        emit DisputeResolved(disputeId, isValid, reason);\n    }\n\n    /// @notice Get dispute details\n    /// @param disputeId Dispute to query\n    /// @return Dispute struct\n    function getDispute(uint256 disputeId) external view returns (Dispute memory) {\n        return disputes[disputeId];\n    }\n\n    /// @notice Check if a dispute can be resolved\n    /// @param disputeId Dispute to check\n    /// @return True if dispute can be resolved\n    function canResolve(uint256 disputeId) external view returns (bool) {\n        Dispute memory dispute = disputes[disputeId];\n\n        if (dispute.resolved) return false;\n        if (block.timestamp > dispute.claimTimestamp + DISPUTE_WINDOW + RESOLUTION_TIMEOUT) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /// @notice Get active disputes for a prover\n    /// @param prover Address to query\n    /// @return Array of dispute IDs\n    function getProverDisputes(address prover) external view returns (uint256[] memory) {\n        uint256 count = 0;\n\n        // Count disputes\n        for (uint256 i = 0; i < disputeCount; i++) {\n            if (disputes[i].prover == prover && !disputes[i].resolved) {\n                count++;\n            }\n        }\n\n        // Collect dispute IDs\n        uint256[] memory disputeIds = new uint256[](count);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < disputeCount; i++) {\n            if (disputes[i].prover == prover && !disputes[i].resolved) {\n                disputeIds[index++] = i;\n            }\n        }\n\n        return disputeIds;\n    }\n\n    /// @notice Get active disputes for a challenger\n    /// @param challenger Address to query\n    /// @return Array of dispute IDs\n    function getChallengerDisputes(address challenger) external view returns (uint256[] memory) {\n        uint256 count = 0;\n\n        // Count disputes\n        for (uint256 i = 0; i < disputeCount; i++) {\n            if (disputes[i].challenger == challenger && !disputes[i].resolved) {\n                count++;\n            }\n        }\n\n        // Collect dispute IDs\n        uint256[] memory disputeIds = new uint256[](count);\n        uint256 index = 0;\n\n        for (uint256 i = 0; i < disputeCount; i++) {\n            if (disputes[i].challenger == challenger && !disputes[i].resolved) {\n                disputeIds[index++] = i;\n            }\n        }\n\n        return disputeIds;\n    }\n\n    /// @notice Update oracle aggregator address (admin function)\n    /// @dev Only for emergency updates, should be governed in production\n    /// @param _newAggregator New oracle aggregator address\n    function updateOracleAggregator(address _newAggregator) external {\n        require(_newAggregator != address(0), \"DisputeResolver: Invalid address\");\n        oracleAggregator = OracleAggregator(_newAggregator);\n    }\n}\n"
    },
    "contracts/oracles/OracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ChainlinkOracleAdapter.sol\";\nimport \"./PythOracleAdapter.sol\";\nimport \"./UniswapV3TWAPAdapter.sol\";\n\n/// @title OracleAggregator\n/// @notice Aggregates 3 oracle sources with Byzantine fault tolerance\n/// @dev Handles: conflicting values, staleness, 30% manipulation, missing updates\n/// @dev Byzantine-resistant: 2/3 honest oracles ensure correct median price\ncontract OracleAggregator {\n\n    ChainlinkOracleAdapter public chainlink;\n    PythOracleAdapter public pyth;\n    UniswapV3TWAPAdapter public uniswapTWAP;\n\n    struct AggregatedPrice {\n        uint256 price;           // Median price from all sources\n        uint256 timestamp;       // Earliest timestamp among sources\n        uint256 confidence;      // Confidence score (0-100)\n        uint256 deviation;       // Max deviation between sources (basis points)\n        uint8 sourceCount;       // Number of oracles that responded\n        bool isHealthy;          // True if passes all checks\n        string[] activeSources;  // Which oracles contributed\n    }\n\n    struct OracleReading {\n        uint256 price;\n        uint256 timestamp;\n        bool success;\n        string source;\n    }\n\n    // Thresholds (from adversarial conditions)\n    uint256 public constant MAX_ACCEPTABLE_DEVIATION = 3000; // 30% (handles adversarial condition #1)\n    uint256 public constant MIN_SOURCES_REQUIRED = 2;        // Need at least 2 oracles (Byzantine tolerance)\n    uint256 public constant MAX_PRICE_AGE = 3600;            // 1 hour staleness limit (handles condition #2)\n\n    event OraclePriceFetched(string source, uint256 price, uint256 timestamp);\n    event OracleFetchFailed(string source, string reason);\n    event PriceAggregated(\n        bytes32 indexed pairId,\n        uint256 medianPrice,\n        uint8 sourceCount,\n        uint256 deviation,\n        bool isHealthy\n    );\n\n    constructor(\n        address _chainlink,\n        address _pyth,\n        address _uniswapTWAP\n    ) {\n        require(_chainlink != address(0), \"OracleAggregator: Invalid Chainlink address\");\n        require(_pyth != address(0), \"OracleAggregator: Invalid Pyth address\");\n        require(_uniswapTWAP != address(0), \"OracleAggregator: Invalid Uniswap address\");\n\n        chainlink = ChainlinkOracleAdapter(_chainlink);\n        pyth = PythOracleAdapter(_pyth);\n        uniswapTWAP = UniswapV3TWAPAdapter(_uniswapTWAP);\n    }\n\n    /// @notice Get aggregated price from all oracle sources\n    /// @dev Handles all 4 adversarial conditions from hackathon spec\n    /// @param pairId Asset pair (e.g., keccak256(\"ETH/USD\"))\n    /// @return Aggregated price data with health metrics\n    function getAggregatedPrice(bytes32 pairId)\n        public\n        returns (AggregatedPrice memory)\n    {\n        OracleReading[] memory readings = new OracleReading[](3);\n        uint8 successCount = 0;\n\n        // 1. Fetch from Chainlink (most decentralized, slowest updates)\n        try chainlink.getLatestPrice(pairId) returns (\n            uint256 price,\n            uint256 timestamp,\n            uint80 /* roundId */\n        ) {\n            readings[successCount++] = OracleReading({\n                price: price,\n                timestamp: timestamp,\n                success: true,\n                source: \"Chainlink\"\n            });\n            emit OraclePriceFetched(\"Chainlink\", price, timestamp);\n        } catch Error(string memory reason) {\n            emit OracleFetchFailed(\"Chainlink\", reason);\n        } catch {\n            emit OracleFetchFailed(\"Chainlink\", \"Unknown error\");\n        }\n\n        // 2. Fetch from Pyth (high-frequency, sub-second updates)\n        try pyth.getLatestPrice(pairId) returns (\n            uint256 price,\n            uint256 timestamp,\n            uint64 /* conf */\n        ) {\n            readings[successCount++] = OracleReading({\n                price: price,\n                timestamp: timestamp,\n                success: true,\n                source: \"Pyth\"\n            });\n            emit OraclePriceFetched(\"Pyth\", price, timestamp);\n        } catch Error(string memory reason) {\n            emit OracleFetchFailed(\"Pyth\", reason);\n        } catch {\n            emit OracleFetchFailed(\"Pyth\", \"Unknown error\");\n        }\n\n        // 3. Fetch from Uniswap V3 TWAP (on-chain, manipulation-resistant)\n        try uniswapTWAP.getLatestPrice(pairId) returns (\n            uint256 price,\n            uint256 timestamp\n        ) {\n            readings[successCount++] = OracleReading({\n                price: price,\n                timestamp: timestamp,\n                success: true,\n                source: \"Uniswap TWAP\"\n            });\n            emit OraclePriceFetched(\"Uniswap TWAP\", price, timestamp);\n        } catch Error(string memory reason) {\n            emit OracleFetchFailed(\"Uniswap TWAP\", reason);\n        } catch {\n            emit OracleFetchFailed(\"Uniswap TWAP\", \"Unknown error\");\n        }\n\n        // ADVERSARIAL CONDITION #3: Handle missing updates\n        // Require at least 2 oracles working (can tolerate 1 failure)\n        require(successCount >= MIN_SOURCES_REQUIRED, \"OracleAggregator: Insufficient oracle sources\");\n\n        // Aggregate results\n        AggregatedPrice memory result = _aggregateReadings(readings, successCount);\n\n        emit PriceAggregated(\n            pairId,\n            result.price,\n            result.sourceCount,\n            result.deviation,\n            result.isHealthy\n        );\n\n        return result;\n    }\n\n    /// @notice Aggregate multiple oracle readings into single price\n    /// @dev Uses median for Byzantine fault tolerance (resistant to 1 malicious oracle)\n    /// @param readings Array of oracle readings\n    /// @param count Number of successful readings\n    /// @return Aggregated price with health metrics\n    function _aggregateReadings(\n        OracleReading[] memory readings,\n        uint8 count\n    ) internal view returns (AggregatedPrice memory) {\n        require(count >= MIN_SOURCES_REQUIRED, \"OracleAggregator: Too few sources\");\n\n        // Extract successful readings\n        uint256[] memory prices = new uint256[](count);\n        uint256[] memory timestamps = new uint256[](count);\n        string[] memory sources = new string[](count);\n\n        for (uint8 i = 0; i < count; i++) {\n            prices[i] = readings[i].price;\n            timestamps[i] = readings[i].timestamp;\n            sources[i] = readings[i].source;\n        }\n\n        // Sort prices for median calculation\n        if (count > 1) {\n            _quickSort(prices, 0, int256(uint256(count - 1)));\n        }\n\n        // Calculate median (Byzantine-resistant: correct if 2/3 honest)\n        // ADVERSARIAL CONDITION #1: Even if 1 oracle reports 30%+ wrong price, median is correct\n        uint256 medianPrice;\n        if (count % 2 == 0) {\n            // Even number: average of middle two\n            medianPrice = (prices[count / 2 - 1] + prices[count / 2]) / 2;\n        } else {\n            // Odd number: middle value\n            medianPrice = prices[count / 2];\n        }\n\n        // Calculate deviation (detect conflicting values)\n        // ADVERSARIAL CONDITION #4: Detect when oracles provide conflicting values\n        uint256 minPrice = prices[0];\n        uint256 maxPrice = prices[count - 1];\n        uint256 deviation = ((maxPrice - minPrice) * 10000) / medianPrice;\n\n        // Calculate confidence (inverse of deviation, scaled 0-100)\n        uint256 confidence = deviation < 10000 ? 10000 - deviation : 0;\n        confidence = (confidence * 100) / 10000;\n\n        // Find earliest timestamp (conservative staleness check)\n        // ADVERSARIAL CONDITION #2: Use most conservative timestamp\n        uint256 earliestTimestamp = timestamps[0];\n        for (uint8 i = 1; i < count; i++) {\n            if (timestamps[i] < earliestTimestamp) {\n                earliestTimestamp = timestamps[i];\n            }\n        }\n\n        // Health checks\n        bool isHealthy = true;\n\n        // Check 1: Deviation within acceptable range (30%)\n        if (deviation > MAX_ACCEPTABLE_DEVIATION) {\n            isHealthy = false; // Conflicting values detected (CONDITION #4)\n        }\n\n        // Check 2: Not too stale\n        if (block.timestamp - earliestTimestamp > MAX_PRICE_AGE) {\n            isHealthy = false; // Outdated data (CONDITION #2)\n        }\n\n        // Check 3: Minimum confidence threshold\n        if (confidence < 50) {\n            isHealthy = false; // Low confidence\n        }\n\n        return AggregatedPrice({\n            price: medianPrice,\n            timestamp: earliestTimestamp,\n            confidence: confidence,\n            deviation: deviation,\n            sourceCount: count,\n            isHealthy: isHealthy,\n            activeSources: sources\n        });\n    }\n\n    /// @notice Quick sort for median calculation (ascending order)\n    /// @dev O(n log n) average case, used for sorting prices\n    /// @param arr Array to sort (modified in-place)\n    /// @param left Left boundary\n    /// @param right Right boundary\n    function _quickSort(uint256[] memory arr, int256 left, int256 right) internal pure {\n        if (left >= right) return;\n\n        int256 i = left;\n        int256 j = right;\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\n\n        while (i <= j) {\n            while (arr[uint256(i)] < pivot) i++;\n            while (pivot < arr[uint256(j)]) j--;\n            if (i <= j) {\n                (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\n                i++;\n                j--;\n            }\n        }\n\n        if (left < j) _quickSort(arr, left, j);\n        if (i < right) _quickSort(arr, i, right);\n    }\n\n    /// @notice Verify if a claimed price is reasonable given current oracle state\n    /// @dev Used in dispute resolution - checks against all 4 adversarial conditions\n    /// @param pairId Asset pair\n    /// @param claimedPrice Price submitted by prover\n    /// @param claimTimestamp When price was claimed\n    /// @return isValid True if claim passes verification\n    /// @return reason Explanation of result\n    function verifyClaimedPrice(\n        bytes32 pairId,\n        uint256 claimedPrice,\n        uint256 claimTimestamp\n    ) external returns (bool isValid, string memory reason) {\n        AggregatedPrice memory agg = getAggregatedPrice(pairId);\n\n        // Check 1: Claimed price within 30% of aggregated median (CONDITION #1)\n        uint256 priceDeviation = claimedPrice > agg.price\n            ? ((claimedPrice - agg.price) * 10000) / agg.price\n            : ((agg.price - claimedPrice) * 10000) / agg.price;\n\n        if (priceDeviation > MAX_ACCEPTABLE_DEVIATION) {\n            return (false, \"Claimed price deviates >30% from oracle consensus\");\n        }\n\n        // Check 2: Oracle data is healthy (CONDITION #2, #4)\n        if (!agg.isHealthy) {\n            return (false, \"Oracle data unhealthy - conflicting or stale\");\n        }\n\n        // Check 3: Timestamp reasonable (CONDITION #2)\n        if (claimTimestamp > block.timestamp) {\n            return (false, \"Claimed timestamp in future\");\n        }\n\n        if (block.timestamp - claimTimestamp > MAX_PRICE_AGE) {\n            return (false, \"Claimed price too old\");\n        }\n\n        return (true, \"Price verified by oracle consensus\");\n    }\n\n    /// @notice Get individual oracle prices for transparency\n    /// @dev Useful for debugging and showing which oracle is outlier\n    /// @param pairId Asset pair\n    /// @return chainlinkPrice Price from Chainlink\n    /// @return pythPrice Price from Pyth\n    /// @return uniswapPrice Price from Uniswap TWAP\n    /// @return chainlinkSuccess True if Chainlink succeeded\n    /// @return pythSuccess True if Pyth succeeded\n    /// @return uniswapSuccess True if Uniswap succeeded\n    function getIndividualPrices(bytes32 pairId)\n        external\n        view\n        returns (\n            uint256 chainlinkPrice,\n            uint256 pythPrice,\n            uint256 uniswapPrice,\n            bool chainlinkSuccess,\n            bool pythSuccess,\n            bool uniswapSuccess\n        )\n    {\n        // Fetch Chainlink\n        try chainlink.getLatestPrice(pairId) returns (\n            uint256 price,\n            uint256,\n            uint80\n        ) {\n            chainlinkPrice = price;\n            chainlinkSuccess = true;\n        } catch {\n            chainlinkSuccess = false;\n        }\n\n        // Fetch Pyth\n        try pyth.getLatestPrice(pairId) returns (\n            uint256 price,\n            uint256,\n            uint64\n        ) {\n            pythPrice = price;\n            pythSuccess = true;\n        } catch {\n            pythSuccess = false;\n        }\n\n        // Fetch Uniswap TWAP\n        try uniswapTWAP.getLatestPrice(pairId) returns (\n            uint256 price,\n            uint256\n        ) {\n            uniswapPrice = price;\n            uniswapSuccess = true;\n        } catch {\n            uniswapSuccess = false;\n        }\n    }\n\n    /// @notice Emergency: Get price even if unhealthy (with explicit warnings)\n    /// @dev Only use when system must proceed despite oracle issues\n    /// @param pairId Asset pair\n    /// @return price Median price (may be unreliable)\n    /// @return warning Explicit warning message\n    function getEmergencyPrice(bytes32 pairId)\n        external\n        returns (uint256 price, string memory warning)\n    {\n        AggregatedPrice memory agg = getAggregatedPrice(pairId);\n\n        if (!agg.isHealthy) {\n            if (agg.deviation > MAX_ACCEPTABLE_DEVIATION) {\n                warning = \"WARNING: Oracle sources conflict >30% - using median with HIGH UNCERTAINTY\";\n            } else if (block.timestamp - agg.timestamp > MAX_PRICE_AGE) {\n                warning = \"WARNING: Oracle data stale - price may not reflect current market\";\n            } else {\n                warning = \"WARNING: Low confidence in oracle data\";\n            }\n        } else {\n            warning = \"\";\n        }\n\n        return (agg.price, warning);\n    }\n}\n"
    },
    "contracts/oracles/PythOracleAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@pythnetwork/pyth-sdk-solidity/IPyth.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\n\n/// @title PythOracleAdapter\n/// @notice Fetches price data from Pyth Network (high-frequency oracle)\n/// @dev Official Sepolia testnet address from https://docs.pyth.network/price-feeds/contract-addresses/evm\ncontract PythOracleAdapter {\n\n    IPyth public pyth;\n\n    // Pyth contract address (Ethereum Sepolia testnet)\n    // Source: https://docs.pyth.network/price-feeds/contract-addresses/evm\n    address public constant PYTH_ADDRESS = 0xDd24F84d36BF92C65F92307595335bdFab5Bbd21;\n\n    // Price feed IDs (Pyth identifiers)\n    // Source: https://pyth.network/developers/price-feed-ids\n    bytes32 public constant ETH_USD_FEED_ID =\n        0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace;\n    bytes32 public constant BTC_USD_FEED_ID =\n        0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43;\n\n    mapping(bytes32 => bytes32) public feedIds; // pairId => Pyth feed ID\n\n    event PriceFeedRegistered(bytes32 indexed pairId, bytes32 indexed feedId);\n    event PriceFetched(bytes32 indexed pairId, uint256 price, uint256 timestamp, uint64 conf);\n\n    constructor() {\n        pyth = IPyth(PYTH_ADDRESS);\n\n        // Register ETH/USD\n        feedIds[keccak256(\"ETH/USD\")] = ETH_USD_FEED_ID;\n        emit PriceFeedRegistered(keccak256(\"ETH/USD\"), ETH_USD_FEED_ID);\n\n        // Register BTC/USD\n        feedIds[keccak256(\"BTC/USD\")] = BTC_USD_FEED_ID;\n        emit PriceFeedRegistered(keccak256(\"BTC/USD\"), BTC_USD_FEED_ID);\n    }\n\n    /// @notice Get latest price from Pyth (normalized to 18 decimals)\n    /// @param pairId Asset pair identifier (e.g., keccak256(\"ETH/USD\"))\n    /// @return price Normalized price (18 decimals)\n    /// @return timestamp Publish time\n    /// @return conf Confidence interval\n    function getLatestPrice(bytes32 pairId)\n        external\n        view\n        returns (\n            uint256 price,\n            uint256 timestamp,\n            uint64 conf\n        )\n    {\n        bytes32 feedId = feedIds[pairId];\n        require(feedId != bytes32(0), \"PythAdapter: Feed not registered\");\n\n        PythStructs.Price memory priceData = pyth.getPriceUnsafe(feedId);\n\n        // Validation\n        require(priceData.price > 0, \"PythAdapter: Invalid price\");\n        require(priceData.publishTime > 0, \"PythAdapter: Invalid timestamp\");\n\n        // Staleness check (Pyth updates every 400ms on mainnet, but Sepolia testnet may be slower)\n        // Allow 30 days for testnet compatibility (Sepolia Pyth data is often stale)\n        require(\n            block.timestamp - priceData.publishTime <= 2592000,\n            \"PythAdapter: Pyth price too stale\"\n        );\n\n        // Normalize to 18 decimals\n        uint256 normalizedPrice = _normalizePrice(\n            uint64(priceData.price),\n            priceData.expo\n        );\n\n        return (normalizedPrice, priceData.publishTime, priceData.conf);\n    }\n\n    /// @notice Normalize Pyth price to 18 decimals\n    /// @dev Pyth prices come with exponent (e.g., price=3000, expo=-8 means $30.00)\n    /// @param price Raw price value\n    /// @param expo Exponent (negative for decimal places)\n    /// @return Normalized price with 18 decimals\n    function _normalizePrice(uint64 price, int32 expo) internal pure returns (uint256) {\n        // Pyth prices: price * 10^expo\n        // Target: 18 decimals\n\n        if (expo < 0) {\n            uint32 absExpo = uint32(-expo);\n            if (absExpo < 18) {\n                // Scale up to 18 decimals\n                return uint256(price) * (10 ** (18 - absExpo));\n            } else {\n                // Already more than 18 decimals, scale down\n                return uint256(price) / (10 ** (absExpo - 18));\n            }\n        } else {\n            // Positive exponent (rare)\n            return uint256(price) * (10 ** (18 + uint32(expo)));\n        }\n    }\n\n    /// @notice Update Pyth price with off-chain data\n    /// @dev Pyth requires price update data from Hermes API\n    /// @param priceUpdateData Price update data from Pyth Hermes\n    function updatePrice(bytes[] calldata priceUpdateData)\n        external\n        payable\n    {\n        uint256 fee = pyth.getUpdateFee(priceUpdateData);\n        require(msg.value >= fee, \"PythAdapter: Insufficient update fee\");\n\n        pyth.updatePriceFeeds{value: fee}(priceUpdateData);\n    }\n\n    /// @notice Get Pyth price without safety checks (unsafe - use with caution)\n    /// @dev Only use this if you need raw data and handle validation yourself\n    /// @param pairId Asset pair identifier\n    /// @return priceData Raw Pyth price struct\n    function getPriceUnsafe(bytes32 pairId)\n        external\n        view\n        returns (PythStructs.Price memory priceData)\n    {\n        bytes32 feedId = feedIds[pairId];\n        require(feedId != bytes32(0), \"PythAdapter: Feed not registered\");\n\n        return pyth.getPriceUnsafe(feedId);\n    }\n\n    /// @notice Get the current update fee for Pyth\n    /// @param updateDataSize Number of price updates\n    /// @return fee Required fee in wei\n    function getUpdateFee(uint256 updateDataSize) external view returns (uint256) {\n        bytes[] memory dummyData = new bytes[](updateDataSize);\n        return pyth.getUpdateFee(dummyData);\n    }\n\n    /// @notice Check if feed is registered\n    /// @param pairId Asset pair to check\n    /// @return True if feed registered\n    function isFeedRegistered(bytes32 pairId) external view returns (bool) {\n        return feedIds[pairId] != bytes32(0);\n    }\n}\n"
    },
    "contracts/oracles/UniswapV3TWAPAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\";\n\n/// @title UniswapV3TWAPAdapter\n/// @notice Fetches time-weighted average price from Uniswap V3 pools\n/// @dev Provides on-chain price oracle resistant to flash loan manipulation\n/// @dev Pool addresses from https://www.geckoterminal.com/sepolia-testnet\ncontract UniswapV3TWAPAdapter {\n\n    struct PoolConfig {\n        address pool;\n        address baseToken;  // Token being priced (e.g., WETH)\n        address quoteToken; // Token price is quoted in (e.g., USDC)\n        uint8 baseDecimals;\n        uint8 quoteDecimals;\n        uint32 twapPeriod;  // Time window for TWAP (seconds)\n        bool isToken0Base;  // True if baseToken is token0 in the pool\n    }\n\n    mapping(bytes32 => PoolConfig) public pools;\n\n    // Uniswap V3 pool addresses (Sepolia testnet)\n    // Source: https://www.geckoterminal.com/sepolia-testnet/pools/0x9799b5edc1aa7d3fad350309b08df3f64914e244\n    address public constant USDC_WETH_POOL_03 = 0x9799b5EDC1aA7D3FAd350309B08df3F64914E244; // 0.3% fee\n\n    // Token addresses on Sepolia (need to verify these)\n    address public constant WETH = 0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14; // WETH on Sepolia\n    address public constant USDC = 0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238; // USDC on Sepolia\n\n    event PoolRegistered(bytes32 indexed pairId, address poolAddress, uint32 twapPeriod);\n    event TWAPCalculated(bytes32 indexed pairId, uint256 price, uint256 timestamp);\n\n    constructor() {\n        // Register WETH/USDC pool\n        // Note: This gives price of WETH in USDC, we map it to ETH/USD\n        pools[keccak256(\"ETH/USD\")] = PoolConfig({\n            pool: USDC_WETH_POOL_03,\n            baseToken: WETH,\n            quoteToken: USDC,\n            baseDecimals: 18,  // WETH has 18 decimals\n            quoteDecimals: 6,  // USDC has 6 decimals\n            twapPeriod: 1800,  // 30 minute TWAP (balance between freshness and security)\n            isToken0Base: false // WETH is typically token1, USDC is token0 (lower address)\n        });\n\n        emit PoolRegistered(keccak256(\"ETH/USD\"), USDC_WETH_POOL_03, 1800);\n    }\n\n    /// @notice Get time-weighted average price from Uniswap V3\n    /// @param pairId Asset pair identifier (e.g., keccak256(\"ETH/USD\"))\n    /// @return price TWAP price (normalized to 18 decimals)\n    /// @return timestamp Current block timestamp (TWAP is current)\n    function getLatestPrice(bytes32 pairId)\n        external\n        view\n        returns (\n            uint256 price,\n            uint256 timestamp\n        )\n    {\n        PoolConfig memory config = pools[pairId];\n        require(config.pool != address(0), \"UniswapAdapter: Pool not configured\");\n\n        IUniswapV3Pool pool = IUniswapV3Pool(config.pool);\n\n        // Get TWAP tick (arithmetic mean over the period)\n        int24 arithmeticMeanTick = _getTWAPTick(pool, config.twapPeriod);\n\n        // Convert tick to price\n        uint256 quoteAmount = _getQuoteAtTick(\n            arithmeticMeanTick,\n            uint128(10 ** config.baseDecimals), // 1 unit of base token (e.g., 1 WETH)\n            config.isToken0Base\n        );\n\n        // Normalize to 18 decimals\n        uint256 normalizedPrice;\n        if (config.quoteDecimals < 18) {\n            // Scale up (e.g., USDC has 6 decimals, multiply by 10^12)\n            normalizedPrice = quoteAmount * (10 ** (18 - config.quoteDecimals));\n        } else {\n            // Scale down (rare case)\n            normalizedPrice = quoteAmount / (10 ** (config.quoteDecimals - 18));\n        }\n\n        return (normalizedPrice, block.timestamp);\n    }\n\n    /// @notice Calculate TWAP tick from Uniswap V3 pool observations\n    /// @dev Queries pool's oracle observations and calculates arithmetic mean tick\n    /// @param pool Uniswap V3 pool contract\n    /// @param period TWAP period in seconds\n    /// @return arithmeticMeanTick The time-weighted average tick\n    function _getTWAPTick(IUniswapV3Pool pool, uint32 period)\n        internal\n        view\n        returns (int24 arithmeticMeanTick)\n    {\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = period; // Start of TWAP window\n        secondsAgos[1] = 0;      // Current time\n\n        // Get cumulative tick data from pool\n        (int56[] memory tickCumulatives, ) = pool.observe(secondsAgos);\n\n        // Calculate arithmetic mean tick over the period\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        arithmeticMeanTick = int24(tickCumulativesDelta / int56(uint56(period)));\n\n        // Round down for negative ticks\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(period)) != 0)) {\n            arithmeticMeanTick--;\n        }\n    }\n\n    /// @notice Convert Uniswap V3 tick to quote amount\n    /// @dev Simplified version of OracleLibrary.getQuoteAtTick for Solidity 0.8\n    /// @param tick The tick to convert\n    /// @param baseAmount Amount of base token (with decimals)\n    /// @param isToken0Base True if base token is token0\n    /// @return quoteAmount The corresponding amount of quote token\n    function _getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        bool isToken0Base\n    ) internal pure returns (uint256 quoteAmount) {\n        // Get sqrtPrice from tick\n        uint160 sqrtPriceX96 = _getSqrtRatioAtTick(tick);\n\n        // Calculate price from sqrtPriceX96\n        // sqrtPriceX96 = sqrt(token1/token0) * 2^96\n        // price = (sqrtPriceX96 / 2^96)^2\n\n        if (sqrtPriceX96 <= type(uint128).max) {\n            uint256 priceX192 = uint256(sqrtPriceX96) * sqrtPriceX96;\n            quoteAmount = isToken0Base\n                ? _mulDiv(priceX192, baseAmount, 1 << 192)\n                : _mulDiv(1 << 192, baseAmount, priceX192);\n        } else {\n            uint256 priceX128 = _mulDiv(sqrtPriceX96, sqrtPriceX96, 1 << 64);\n            quoteAmount = isToken0Base\n                ? _mulDiv(priceX128, baseAmount, 1 << 128)\n                : _mulDiv(1 << 128, baseAmount, priceX128);\n        }\n    }\n\n    /// @notice Get sqrtPriceX96 from tick\n    /// @dev Simplified implementation for common tick ranges\n    /// @param tick The tick to convert\n    /// @return sqrtPriceX96 The sqrt price encoded as a Q64.96\n    function _getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        require(absTick <= uint256(int256(type(int24).max)), \"T\");\n\n        uint256 ratio = absTick & 0x1 != 0\n            ? 0xfffcb933bd6fad37aa2d162d1a594001\n            : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Full precision multiplication\n    /// @dev Calculates floor(a×b÷denominator) with full precision\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function _mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        require(denominator > prod1);\n\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        uint256 twos = denominator & (~denominator + 1);\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        uint256 inv = (3 * denominator) ^ 2;\n        inv *= 2 - denominator * inv;\n        inv *= 2 - denominator * inv;\n        inv *= 2 - denominator * inv;\n        inv *= 2 - denominator * inv;\n        inv *= 2 - denominator * inv;\n        inv *= 2 - denominator * inv;\n\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Check if pool has sufficient history for TWAP\n    /// @dev Verifies pool has observations covering the TWAP period\n    /// @param pairId Asset pair to check\n    /// @return True if pool is healthy and has sufficient data\n    function isPoolHealthy(bytes32 pairId) external view returns (bool) {\n        PoolConfig memory config = pools[pairId];\n        if (config.pool == address(0)) return false;\n\n        IUniswapV3Pool pool = IUniswapV3Pool(config.pool);\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = config.twapPeriod;\n        secondsAgos[1] = 0;\n\n        // Check if pool has observations for TWAP period\n        try pool.observe(secondsAgos) returns (\n            int56[] memory,\n            uint160[] memory\n        ) {\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    /// @notice Get pool configuration\n    /// @param pairId Asset pair to query\n    /// @return config Pool configuration struct\n    function getPoolConfig(bytes32 pairId) external view returns (PoolConfig memory) {\n        return pools[pairId];\n    }\n\n    /// @notice Check if pool is registered\n    /// @param pairId Asset pair to check\n    /// @return True if pool registered\n    function isPoolRegistered(bytes32 pairId) external view returns (bool) {\n        return pools[pairId].pool != address(0);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}