{
  "address": "0xa7b8405Ac7e7f350D80Bb86F8807192be7244Ddb",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_chainlink",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_pyth",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_uniswapTWAP",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "source",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "name": "OracleFetchFailed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "source",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        }
      ],
      "name": "OraclePriceFetched",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "pairId",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "medianPrice",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "sourceCount",
          "type": "uint8"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "deviation",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isHealthy",
          "type": "bool"
        }
      ],
      "name": "PriceAggregated",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "MAX_ACCEPTABLE_DEVIATION",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MAX_PRICE_AGE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "MIN_SOURCES_REQUIRED",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "chainlink",
      "outputs": [
        {
          "internalType": "contract ChainlinkOracleAdapter",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "pairId",
          "type": "bytes32"
        }
      ],
      "name": "getAggregatedPrice",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "price",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "confidence",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "deviation",
              "type": "uint256"
            },
            {
              "internalType": "uint8",
              "name": "sourceCount",
              "type": "uint8"
            },
            {
              "internalType": "bool",
              "name": "isHealthy",
              "type": "bool"
            },
            {
              "internalType": "string[]",
              "name": "activeSources",
              "type": "string[]"
            }
          ],
          "internalType": "struct OracleAggregator.AggregatedPrice",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "pairId",
          "type": "bytes32"
        }
      ],
      "name": "getEmergencyPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "price",
          "type": "uint256"
        },
        {
          "internalType": "string",
          "name": "warning",
          "type": "string"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "pairId",
          "type": "bytes32"
        }
      ],
      "name": "getIndividualPrices",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "chainlinkPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "pythPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "uniswapPrice",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "chainlinkSuccess",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "pythSuccess",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "uniswapSuccess",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pyth",
      "outputs": [
        {
          "internalType": "contract PythOracleAdapter",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "uniswapTWAP",
      "outputs": [
        {
          "internalType": "contract UniswapV3TWAPAdapter",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "pairId",
          "type": "bytes32"
        },
        {
          "internalType": "uint256",
          "name": "claimedPrice",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "claimTimestamp",
          "type": "uint256"
        }
      ],
      "name": "verifyClaimedPrice",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isValid",
          "type": "bool"
        },
        {
          "internalType": "string",
          "name": "reason",
          "type": "string"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xf645585ed6df37fd2cec0e853feb75267e115349f78a591f2347eb81ad654eca",
  "receipt": {
    "to": null,
    "from": "0x2f729eD2EFd4AE0fc0Bb3d5e9Ba5F77c0b6d8374",
    "contractAddress": "0xa7b8405Ac7e7f350D80Bb86F8807192be7244Ddb",
    "transactionIndex": 14,
    "gasUsed": "1594398",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x59e19ad092c06efe0c8b6c04ac792448f21ee03c8c08a110cf530b20cac52810",
    "transactionHash": "0xf645585ed6df37fd2cec0e853feb75267e115349f78a591f2347eb81ad654eca",
    "logs": [],
    "blockNumber": 9778084,
    "cumulativeGasUsed": "3180955",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xa8dBDa42f882140eF0f1ca48435441dCba635C4a",
    "0xb036C992911C98C7BcfcA5f7630829D74e17F270",
    "0x6BD710D43929dba6b2E384734E81f3f3BD0A464a"
  ],
  "numDeployments": 1,
  "solcInputHash": "36e2fb7e37fcd5942e57e0a5463f4682",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chainlink\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pyth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapTWAP\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"source\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"OracleFetchFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"source\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"OraclePriceFetched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"pairId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"medianPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"sourceCount\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deviation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isHealthy\",\"type\":\"bool\"}],\"name\":\"PriceAggregated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_ACCEPTABLE_DEVIATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PRICE_AGE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_SOURCES_REQUIRED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlink\",\"outputs\":[{\"internalType\":\"contract ChainlinkOracleAdapter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"pairId\",\"type\":\"bytes32\"}],\"name\":\"getAggregatedPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"confidence\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deviation\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"sourceCount\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isHealthy\",\"type\":\"bool\"},{\"internalType\":\"string[]\",\"name\":\"activeSources\",\"type\":\"string[]\"}],\"internalType\":\"struct OracleAggregator.AggregatedPrice\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"pairId\",\"type\":\"bytes32\"}],\"name\":\"getEmergencyPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"warning\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"pairId\",\"type\":\"bytes32\"}],\"name\":\"getIndividualPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"chainlinkPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pythPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"uniswapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"chainlinkSuccess\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"pythSuccess\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"uniswapSuccess\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pyth\",\"outputs\":[{\"internalType\":\"contract PythOracleAdapter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapTWAP\",\"outputs\":[{\"internalType\":\"contract UniswapV3TWAPAdapter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"pairId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"claimedPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimTimestamp\",\"type\":\"uint256\"}],\"name\":\"verifyClaimedPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Handles: conflicting values, staleness, 30% manipulation, missing updatesByzantine-resistant: 2/3 honest oracles ensure correct median price\",\"kind\":\"dev\",\"methods\":{\"getAggregatedPrice(bytes32)\":{\"details\":\"Handles all 4 adversarial conditions from hackathon spec\",\"params\":{\"pairId\":\"Asset pair (e.g., keccak256(\\\"ETH/USD\\\"))\"},\"returns\":{\"_0\":\"Aggregated price data with health metrics\"}},\"getEmergencyPrice(bytes32)\":{\"details\":\"Only use when system must proceed despite oracle issues\",\"params\":{\"pairId\":\"Asset pair\"},\"returns\":{\"price\":\"Median price (may be unreliable)\",\"warning\":\"Explicit warning message\"}},\"getIndividualPrices(bytes32)\":{\"details\":\"Useful for debugging and showing which oracle is outlier\",\"params\":{\"pairId\":\"Asset pair\"},\"returns\":{\"chainlinkPrice\":\"Price from Chainlink\",\"chainlinkSuccess\":\"True if Chainlink succeeded\",\"pythPrice\":\"Price from Pyth\",\"pythSuccess\":\"True if Pyth succeeded\",\"uniswapPrice\":\"Price from Uniswap TWAP\",\"uniswapSuccess\":\"True if Uniswap succeeded\"}},\"verifyClaimedPrice(bytes32,uint256,uint256)\":{\"details\":\"Used in dispute resolution - checks against all 4 adversarial conditions\",\"params\":{\"claimTimestamp\":\"When price was claimed\",\"claimedPrice\":\"Price submitted by prover\",\"pairId\":\"Asset pair\"},\"returns\":{\"isValid\":\"True if claim passes verification\",\"reason\":\"Explanation of result\"}}},\"title\":\"OracleAggregator\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getAggregatedPrice(bytes32)\":{\"notice\":\"Get aggregated price from all oracle sources\"},\"getEmergencyPrice(bytes32)\":{\"notice\":\"Emergency: Get price even if unhealthy (with explicit warnings)\"},\"getIndividualPrices(bytes32)\":{\"notice\":\"Get individual oracle prices for transparency\"},\"verifyClaimedPrice(bytes32,uint256,uint256)\":{\"notice\":\"Verify if a claimed price is reasonable given current oracle state\"}},\"notice\":\"Aggregates 3 oracle sources with Byzantine fault tolerance\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/oracles/OracleAggregator.sol\":\"OracleAggregator\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// solhint-disable-next-line interface-starts-with-i\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(\\n    uint80 _roundId\\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\\n}\\n\",\"keccak256\":\"0x257a8d28fa83d3d942547c8e129ef465e4b5f3f31171e7be4739a4c98da6b4f0\",\"license\":\"MIT\"},\"@pythnetwork/pyth-sdk-solidity/IPyth.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./PythStructs.sol\\\";\\nimport \\\"./IPythEvents.sol\\\";\\n\\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\\n/// @dev Please refer to the guidance at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how to consume prices safely.\\n/// @author Pyth Data Association\\ninterface IPyth is IPythEvents {\\n    /// @notice Returns the price of a price feed without any sanity checks.\\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\\n    ///\\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\\n    /// sufficiently recent for their application. If you are considering using this function, it may be\\n    /// safer / easier to use `getPriceNoOlderThan`.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getPriceUnsafe(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\\n    /// recently.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getPriceNoOlderThan(\\n        bytes32 id,\\n        uint age\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\\n    /// However, if the price is not recent this function returns the latest available price.\\n    ///\\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\\n    /// the returned price is recent or useful for any particular application.\\n    ///\\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\\n    /// sufficiently recent for their application. If you are considering using this function, it may be\\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getEmaPriceUnsafe(\\n        bytes32 id\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\\n    /// of the current time.\\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\\n    /// recently.\\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\\n    function getEmaPriceNoOlderThan(\\n        bytes32 id,\\n        uint age\\n    ) external view returns (PythStructs.Price memory price);\\n\\n    /// @notice Update price feeds with given update messages.\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    /// Prices will be updated if they are more recent than the current stored prices.\\n    /// The call will succeed even if the update is not the most recent.\\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\\n    /// @param updateData Array of price update data.\\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\\n\\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\\n    ///\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    ///\\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\\n    ///\\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\\n    /// @param updateData Array of price update data.\\n    /// @param priceIds Array of price ids.\\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\\n    function updatePriceFeedsIfNecessary(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds,\\n        uint64[] calldata publishTimes\\n    ) external payable;\\n\\n    /// @notice Returns the required fee to update an array of price updates.\\n    /// @param updateData Array of price update data.\\n    /// @return feeAmount The required fee in Wei.\\n    function getUpdateFee(\\n        bytes[] calldata updateData\\n    ) external view returns (uint feeAmount);\\n\\n    /// @notice Returns the required fee to update a TWAP price.\\n    /// @param updateData Array of price update data.\\n    /// @return feeAmount The required fee in Wei.\\n    function getTwapUpdateFee(\\n        bytes[] calldata updateData\\n    ) external view returns (uint feeAmount);\\n\\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\\n    /// within `minPublishTime` and `maxPublishTime`.\\n    ///\\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\\n    /// otherwise, please consider using `updatePriceFeeds`. This method will not store the price updates on-chain.\\n    ///\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    ///\\n    ///\\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\\n    /// no update for any of the given `priceIds` within the given time range.\\n    /// @param updateData Array of price update data.\\n    /// @param priceIds Array of price ids.\\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\\n    function parsePriceFeedUpdates(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds,\\n        uint64 minPublishTime,\\n        uint64 maxPublishTime\\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\\n\\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\\n    /// within `minPublishTime` and `maxPublishTime,` but choose to store price updates if `storeUpdatesIfFresh`.\\n    ///\\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\\n    /// otherwise, please consider using `updatePriceFeeds`. This method may store the price updates on-chain, if they\\n    /// are more recent than the current stored prices.\\n    ///\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the length of the `updateData` array.\\n    ///\\n    /// This method will eventually allow the caller to determine whether parsed price feeds should update\\n    /// the stored values as well.\\n    ///\\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\\n    /// no update for any of the given `priceIds` within the given time range.\\n    /// @param updateData Array of price update data.\\n    /// @param priceIds Array of price ids.\\n    /// @param minAllowedPublishTime minimum acceptable publishTime for the given `priceIds`.\\n    /// @param maxAllowedPublishTime maximum acceptable publishTime for the given `priceIds`.\\n    /// @param storeUpdatesIfFresh flag for the parse function to\\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\\n    function parsePriceFeedUpdatesWithConfig(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds,\\n        uint64 minAllowedPublishTime,\\n        uint64 maxAllowedPublishTime,\\n        bool checkUniqueness,\\n        bool checkUpdateDataIsMinimal,\\n        bool storeUpdatesIfFresh\\n    )\\n        external\\n        payable\\n        returns (\\n            PythStructs.PriceFeed[] memory priceFeeds,\\n            uint64[] memory slots\\n        );\\n\\n    /// @notice Parse time-weighted average price (TWAP) from two consecutive price updates for the given `priceIds`.\\n    ///\\n    /// This method calculates TWAP between two data points by processing the difference in cumulative price values\\n    /// divided by the time period. It requires exactly two updates that contain valid price information\\n    /// for all the requested price IDs.\\n    ///\\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\\n    /// `getUpdateFee` with the updateData array.\\n    ///\\n    /// @dev Reverts if:\\n    /// - The transferred fee is not sufficient\\n    /// - The updateData is invalid or malformed\\n    /// - The updateData array does not contain exactly 2 updates\\n    /// - There is no update for any of the given `priceIds`\\n    /// - The time ordering between data points is invalid (start time must be before end time)\\n    /// @param updateData Array containing exactly two price updates (start and end points for TWAP calculation)\\n    /// @param priceIds Array of price ids to calculate TWAP for\\n    /// @return twapPriceFeeds Array of TWAP price feeds corresponding to the given `priceIds` (with the same order)\\n    function parseTwapPriceFeedUpdates(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds\\n    )\\n        external\\n        payable\\n        returns (PythStructs.TwapPriceFeed[] memory twapPriceFeeds);\\n\\n    /// @notice Similar to `parsePriceFeedUpdates` but ensures the updates returned are\\n    /// the first updates published in minPublishTime. That is, if there are multiple updates for a given timestamp,\\n    /// this method will return the first update. This method may store the price updates on-chain, if they\\n    /// are more recent than the current stored prices.\\n    ///\\n    ///\\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\\n    /// no update for any of the given `priceIds` within the given time range and uniqueness condition.\\n    /// @param updateData Array of price update data.\\n    /// @param priceIds Array of price ids.\\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\\n    function parsePriceFeedUpdatesUnique(\\n        bytes[] calldata updateData,\\n        bytes32[] calldata priceIds,\\n        uint64 minPublishTime,\\n        uint64 maxPublishTime\\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\\n}\\n\",\"keccak256\":\"0xdd07c2c02083b3cbb23f40608c15c5531f59014955216fc7f513926e01c8b70b\",\"license\":\"Apache-2.0\"},\"@pythnetwork/pyth-sdk-solidity/IPythEvents.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/// @title IPythEvents contains the events that Pyth contract emits.\\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\\ninterface IPythEvents {\\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\\n    /// @param id The Pyth Price Feed ID.\\n    /// @param publishTime Publish time of the given price update.\\n    /// @param price Price of the given price update.\\n    /// @param conf Confidence interval of the given price update.\\n    event PriceFeedUpdate(\\n        bytes32 indexed id,\\n        uint64 publishTime,\\n        int64 price,\\n        uint64 conf\\n    );\\n\\n    /// @dev Emitted when the TWAP price feed with `id` has received a fresh update.\\n    /// @param id The Pyth Price Feed ID.\\n    /// @param startTime Start time of the TWAP.\\n    /// @param endTime End time of the TWAP.\\n    /// @param twapPrice Price of the TWAP.\\n    /// @param twapConf Confidence interval of the TWAP.\\n    /// @param downSlotsRatio Down slot ratio of the TWAP.\\n    event TwapPriceFeedUpdate(\\n        bytes32 indexed id,\\n        uint64 startTime,\\n        uint64 endTime,\\n        int64 twapPrice,\\n        uint64 twapConf,\\n        uint32 downSlotsRatio\\n    );\\n}\\n\",\"keccak256\":\"0xd67239becd2c39bd9d065830be24e70606f5747ab31b8818bea849d09ac17ddc\",\"license\":\"Apache-2.0\"},\"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\ncontract PythStructs {\\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\\n    //\\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\\n    // Both the price and confidence are stored in a fixed-point numeric representation,\\n    // `x * (10^expo)`, where `expo` is the exponent.\\n    //\\n    // Please refer to the documentation at https://docs.pyth.network/documentation/pythnet-price-feeds/best-practices for how\\n    // to how this price safely.\\n    struct Price {\\n        // Price\\n        int64 price;\\n        // Confidence interval around the price\\n        uint64 conf;\\n        // Price exponent\\n        int32 expo;\\n        // Unix timestamp describing when the price was published\\n        uint publishTime;\\n    }\\n\\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\\n    struct PriceFeed {\\n        // The price ID.\\n        bytes32 id;\\n        // Latest available price\\n        Price price;\\n        // Latest available exponentially-weighted moving average price\\n        Price emaPrice;\\n    }\\n\\n    struct TwapPriceFeed {\\n        // The price ID.\\n        bytes32 id;\\n        // Start time of the TWAP\\n        uint64 startTime;\\n        // End time of the TWAP\\n        uint64 endTime;\\n        // TWAP price\\n        Price twap;\\n        // Down slot ratio represents the ratio of price feed updates that were missed or unavailable\\n        // during the TWAP period, expressed as a fixed-point number between 0 and 1e6 (100%).\\n        // For example:\\n        //   - 0 means all price updates were available\\n        //   - 500_000 means 50% of updates were missed\\n        //   - 1_000_000 means all updates were missed\\n        // This can be used to assess the quality/reliability of the TWAP calculation.\\n        // Applications should define a maximum acceptable ratio (e.g. 100000 for 10%)\\n        // and revert if downSlotsRatio exceeds it.\\n        uint32 downSlotsRatio;\\n    }\\n\\n    // Information used to calculate time-weighted average prices (TWAP)\\n    struct TwapPriceInfo {\\n        // slot 1\\n        int128 cumulativePrice;\\n        uint128 cumulativeConf;\\n        // slot 2\\n        uint64 numDownSlots;\\n        uint64 publishSlot;\\n        uint64 publishTime;\\n        uint64 prevPublishTime;\\n        // slot 3\\n        int32 expo;\\n    }\\n}\\n\",\"keccak256\":\"0x474436bf0d558cc9b2c00a9d0ce318147acdf7963f34ef4acadb9248e65bbc7b\",\"license\":\"Apache-2.0\"},\"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport './pool/IUniswapV3PoolImmutables.sol';\\nimport './pool/IUniswapV3PoolState.sol';\\nimport './pool/IUniswapV3PoolDerivedState.sol';\\nimport './pool/IUniswapV3PoolActions.sol';\\nimport './pool/IUniswapV3PoolOwnerActions.sol';\\nimport './pool/IUniswapV3PoolEvents.sol';\\n\\n/// @title The interface for a Uniswap V3 Pool\\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\\n/// to the ERC20 specification\\n/// @dev The pool interface is broken up into many smaller pieces\\ninterface IUniswapV3Pool is\\n    IUniswapV3PoolImmutables,\\n    IUniswapV3PoolState,\\n    IUniswapV3PoolDerivedState,\\n    IUniswapV3PoolActions,\\n    IUniswapV3PoolOwnerActions,\\n    IUniswapV3PoolEvents\\n{\\n\\n}\\n\",\"keccak256\":\"0xfe6113d518466cd6652c85b111e01f33eb62157f49ae5ed7d5a3947a2044adb1\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Permissionless pool actions\\n/// @notice Contains pool methods that can be called by anyone\\ninterface IUniswapV3PoolActions {\\n    /// @notice Sets the initial price for the pool\\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\\n    function initialize(uint160 sqrtPriceX96) external;\\n\\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\\n    /// @param recipient The address for which the liquidity will be created\\n    /// @param tickLower The lower tick of the position in which to add liquidity\\n    /// @param tickUpper The upper tick of the position in which to add liquidity\\n    /// @param amount The amount of liquidity to mint\\n    /// @param data Any data that should be passed through to the callback\\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n    function mint(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount,\\n        bytes calldata data\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Collects tokens owed to a position\\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\\n    /// @param recipient The address which should receive the fees collected\\n    /// @param tickLower The lower tick of the position for which to collect fees\\n    /// @param tickUpper The upper tick of the position for which to collect fees\\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(\\n        address recipient,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n\\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\\n    /// @dev Fees must be collected separately via a call to #collect\\n    /// @param tickLower The lower tick of the position for which to burn liquidity\\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\\n    /// @param amount How much liquidity to burn\\n    /// @return amount0 The amount of token0 sent to the recipient\\n    /// @return amount1 The amount of token1 sent to the recipient\\n    function burn(\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 amount\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Swap token0 for token1, or token1 for token0\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\\n    /// @param recipient The address to receive the output of the swap\\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\\n    /// @param data Any data to be passed through to the callback\\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n\\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\\n    /// @param recipient The address which will receive the token0 and token1 amounts\\n    /// @param amount0 The amount of token0 to send\\n    /// @param amount1 The amount of token1 to send\\n    /// @param data Any data to be passed through to the callback\\n    function flash(\\n        address recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        bytes calldata data\\n    ) external;\\n\\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\\n    /// the input observationCardinalityNext.\\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\\n}\\n\",\"keccak256\":\"0x9453dd0e7442188667d01d9b65de3f1e14e9511ff3e303179a15f6fc267f7634\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that is not stored\\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\\n/// blockchain. The functions here may have variable gas costs.\\ninterface IUniswapV3PoolDerivedState {\\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\\n    /// you must call it with secondsAgos = [3600, 0].\\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\\n    /// timestamp\\n    function observe(uint32[] calldata secondsAgos)\\n        external\\n        view\\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\\n\\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\\n    /// snapshot is taken and the second snapshot is taken.\\n    /// @param tickLower The lower tick of the range\\n    /// @param tickUpper The upper tick of the range\\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\\n        external\\n        view\\n        returns (\\n            int56 tickCumulativeInside,\\n            uint160 secondsPerLiquidityInsideX128,\\n            uint32 secondsInside\\n        );\\n}\\n\",\"keccak256\":\"0xe603ac5b17ecdee73ba2b27efdf386c257a19c14206e87eee77e2017b742d9e5\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Events emitted by a pool\\n/// @notice Contains all events emitted by the pool\\ninterface IUniswapV3PoolEvents {\\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\\n\\n    /// @notice Emitted when liquidity is minted for a given position\\n    /// @param sender The address that minted the liquidity\\n    /// @param owner The owner of the position and recipient of any minted liquidity\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount The amount of liquidity minted to the position range\\n    /// @param amount0 How much token0 was required for the minted liquidity\\n    /// @param amount1 How much token1 was required for the minted liquidity\\n    event Mint(\\n        address sender,\\n        address indexed owner,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    /// @notice Emitted when fees are collected by the owner of a position\\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\\n    /// @param owner The owner of the position for which fees are collected\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount0 The amount of token0 fees collected\\n    /// @param amount1 The amount of token1 fees collected\\n    event Collect(\\n        address indexed owner,\\n        address recipient,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount0,\\n        uint128 amount1\\n    );\\n\\n    /// @notice Emitted when a position's liquidity is removed\\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\\n    /// @param owner The owner of the position for which liquidity is removed\\n    /// @param tickLower The lower tick of the position\\n    /// @param tickUpper The upper tick of the position\\n    /// @param amount The amount of liquidity to remove\\n    /// @param amount0 The amount of token0 withdrawn\\n    /// @param amount1 The amount of token1 withdrawn\\n    event Burn(\\n        address indexed owner,\\n        int24 indexed tickLower,\\n        int24 indexed tickUpper,\\n        uint128 amount,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    /// @notice Emitted by the pool for any swaps between token0 and token1\\n    /// @param sender The address that initiated the swap call, and that received the callback\\n    /// @param recipient The address that received the output of the swap\\n    /// @param amount0 The delta of the token0 balance of the pool\\n    /// @param amount1 The delta of the token1 balance of the pool\\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\\n    /// @param liquidity The liquidity of the pool after the swap\\n    /// @param tick The log base 1.0001 of price of the pool after the swap\\n    event Swap(\\n        address indexed sender,\\n        address indexed recipient,\\n        int256 amount0,\\n        int256 amount1,\\n        uint160 sqrtPriceX96,\\n        uint128 liquidity,\\n        int24 tick\\n    );\\n\\n    /// @notice Emitted by the pool for any flashes of token0/token1\\n    /// @param sender The address that initiated the swap call, and that received the callback\\n    /// @param recipient The address that received the tokens from flash\\n    /// @param amount0 The amount of token0 that was flashed\\n    /// @param amount1 The amount of token1 that was flashed\\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\\n    event Flash(\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 amount0,\\n        uint256 amount1,\\n        uint256 paid0,\\n        uint256 paid1\\n    );\\n\\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\\n    /// just before a mint/swap/burn.\\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\\n    event IncreaseObservationCardinalityNext(\\n        uint16 observationCardinalityNextOld,\\n        uint16 observationCardinalityNextNew\\n    );\\n\\n    /// @notice Emitted when the protocol fee is changed by the pool\\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\\n\\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\\n    /// @param sender The address that collects the protocol fees\\n    /// @param recipient The address that receives the collected protocol fees\\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\\n}\\n\",\"keccak256\":\"0x8071514d0fe5d17d6fbd31c191cdfb703031c24e0ece3621d88ab10e871375cd\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that never changes\\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\\ninterface IUniswapV3PoolImmutables {\\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\\n    /// @return The contract address\\n    function factory() external view returns (address);\\n\\n    /// @notice The first of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token0() external view returns (address);\\n\\n    /// @notice The second of the two tokens of the pool, sorted by address\\n    /// @return The token contract address\\n    function token1() external view returns (address);\\n\\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\\n    /// @return The fee\\n    function fee() external view returns (uint24);\\n\\n    /// @notice The pool tick spacing\\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\\n    /// This value is an int24 to avoid casting even though it is always positive.\\n    /// @return The tick spacing\\n    function tickSpacing() external view returns (int24);\\n\\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\n    /// @return The max amount of liquidity per tick\\n    function maxLiquidityPerTick() external view returns (uint128);\\n}\\n\",\"keccak256\":\"0xf6e5d2cd1139c4c276bdbc8e1d2b256e456c866a91f1b868da265c6d2685c3f7\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Permissioned pool actions\\n/// @notice Contains pool methods that may only be called by the factory owner\\ninterface IUniswapV3PoolOwnerActions {\\n    /// @notice Set the denominator of the protocol's % share of the fees\\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\\n\\n    /// @notice Collect the protocol fee accrued to the pool\\n    /// @param recipient The address to which collected protocol fees should be sent\\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\\n    /// @return amount0 The protocol fee collected in token0\\n    /// @return amount1 The protocol fee collected in token1\\n    function collectProtocol(\\n        address recipient,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n}\\n\",\"keccak256\":\"0x759b78a2918af9e99e246dc3af084f654e48ef32bb4e4cb8a966aa3dcaece235\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that can change\\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\\n/// per transaction\\ninterface IUniswapV3PoolState {\\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\n    /// when accessed externally.\\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\\n    /// boundary.\\n    /// observationIndex The index of the last oracle observation that was written,\\n    /// observationCardinality The current maximum number of observations stored in the pool,\\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\n    /// feeProtocol The protocol fee for both tokens of the pool.\\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\\n    /// unlocked Whether the pool is currently locked to reentrancy\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal0X128() external view returns (uint256);\\n\\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\n    /// @dev This value can overflow the uint256\\n    function feeGrowthGlobal1X128() external view returns (uint256);\\n\\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\\n    /// @dev Protocol fees will never exceed uint128 max in either token\\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\\n\\n    /// @notice The currently in range liquidity available to the pool\\n    /// @dev This value has no relationship to the total liquidity across all ticks\\n    function liquidity() external view returns (uint128);\\n\\n    /// @notice Look up information about a specific tick in the pool\\n    /// @param tick The tick to look up\\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\\n    /// tick upper,\\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\\n    /// a specific position.\\n    function ticks(int24 tick)\\n        external\\n        view\\n        returns (\\n            uint128 liquidityGross,\\n            int128 liquidityNet,\\n            uint256 feeGrowthOutside0X128,\\n            uint256 feeGrowthOutside1X128,\\n            int56 tickCumulativeOutside,\\n            uint160 secondsPerLiquidityOutsideX128,\\n            uint32 secondsOutside,\\n            bool initialized\\n        );\\n\\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n\\n    /// @notice Returns the information about a position by the position's key\\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\\n    /// @return _liquidity The amount of liquidity in the position,\\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\\n    function positions(bytes32 key)\\n        external\\n        view\\n        returns (\\n            uint128 _liquidity,\\n            uint256 feeGrowthInside0LastX128,\\n            uint256 feeGrowthInside1LastX128,\\n            uint128 tokensOwed0,\\n            uint128 tokensOwed1\\n        );\\n\\n    /// @notice Returns data about a specific observation index\\n    /// @param index The element of the observations array to fetch\\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\n    /// ago, rather than at a specific index in the array.\\n    /// @return blockTimestamp The timestamp of the observation,\\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\\n    function observations(uint256 index)\\n        external\\n        view\\n        returns (\\n            uint32 blockTimestamp,\\n            int56 tickCumulative,\\n            uint160 secondsPerLiquidityCumulativeX128,\\n            bool initialized\\n        );\\n}\\n\",\"keccak256\":\"0x852dc1f5df7dcf7f11e7bb3eed79f0cea72ad4b25f6a9d2c35aafb48925fd49f\",\"license\":\"GPL-2.0-or-later\"},\"contracts/oracles/ChainlinkOracleAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\\\";\\n\\n/// @title ChainlinkOracleAdapter\\n/// @notice Fetches price data from Chainlink decentralized oracle network\\n/// @dev Official Sepolia testnet addresses from https://docs.chain.link/data-feeds/price-feeds/addresses\\ncontract ChainlinkOracleAdapter {\\n\\n    struct PriceFeed {\\n        AggregatorV3Interface feed;\\n        uint8 decimals;\\n        string description;\\n        uint256 heartbeat; // Max acceptable staleness (seconds)\\n    }\\n\\n    // Feed registry: asset pair => Chainlink aggregator\\n    mapping(bytes32 => PriceFeed) public priceFeeds;\\n\\n    // Chainlink aggregator addresses (Sepolia testnet)\\n    // Source: https://docs.chain.link/data-feeds/price-feeds/addresses\\n    address public constant ETH_USD_FEED = 0x694AA1769357215DE4FAC081bf1f309aDC325306;\\n    address public constant BTC_USD_FEED = 0x1b44F3514812d835EB1BDB0acB33d3fA3351Ee43;\\n    address public constant LINK_USD_FEED = 0xc59E3633BAAC79493d908e63626716e204A45EdF;\\n\\n    event PriceFeedRegistered(bytes32 indexed pairId, address feedAddress, string description);\\n    event PriceFetched(bytes32 indexed pairId, uint256 price, uint256 timestamp, uint80 roundId);\\n\\n    constructor() {\\n        // Register ETH/USD feed\\n        _registerFeed(\\n            keccak256(\\\"ETH/USD\\\"),\\n            ETH_USD_FEED,\\n            8,\\n            \\\"ETH/USD Chainlink\\\",\\n            3600 // 1 hour max staleness\\n        );\\n\\n        // Register BTC/USD feed\\n        _registerFeed(\\n            keccak256(\\\"BTC/USD\\\"),\\n            BTC_USD_FEED,\\n            8,\\n            \\\"BTC/USD Chainlink\\\",\\n            3600\\n        );\\n\\n        // Register LINK/USD feed\\n        _registerFeed(\\n            keccak256(\\\"LINK/USD\\\"),\\n            LINK_USD_FEED,\\n            8,\\n            \\\"LINK/USD Chainlink\\\",\\n            3600\\n        );\\n    }\\n\\n    /// @notice Register a new price feed\\n    /// @param pairId Identifier for the trading pair\\n    /// @param feedAddress Chainlink aggregator address\\n    /// @param decimals Number of decimals in the feed\\n    /// @param description Human-readable description\\n    /// @param heartbeat Maximum acceptable staleness in seconds\\n    function _registerFeed(\\n        bytes32 pairId,\\n        address feedAddress,\\n        uint8 decimals,\\n        string memory description,\\n        uint256 heartbeat\\n    ) internal {\\n        priceFeeds[pairId] = PriceFeed({\\n            feed: AggregatorV3Interface(feedAddress),\\n            decimals: decimals,\\n            description: description,\\n            heartbeat: heartbeat\\n        });\\n\\n        emit PriceFeedRegistered(pairId, feedAddress, description);\\n    }\\n\\n    /// @notice Fetch latest price from Chainlink\\n    /// @param pairId Asset pair identifier (e.g., keccak256(\\\"ETH/USD\\\"))\\n    /// @return price Latest price (normalized to 18 decimals)\\n    /// @return timestamp When price was last updated\\n    /// @return roundId Chainlink round ID for verification\\n    function getLatestPrice(bytes32 pairId)\\n        external\\n        view\\n        returns (\\n            uint256 price,\\n            uint256 timestamp,\\n            uint80 roundId\\n        )\\n    {\\n        PriceFeed memory feed = priceFeeds[pairId];\\n        require(address(feed.feed) != address(0), \\\"ChainlinkAdapter: Feed not registered\\\");\\n\\n        (\\n            uint80 _roundId,\\n            int256 answer,\\n            ,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        ) = feed.feed.latestRoundData();\\n\\n        // Validation checks\\n        require(answer > 0, \\\"ChainlinkAdapter: Invalid price (non-positive)\\\");\\n        require(updatedAt > 0, \\\"ChainlinkAdapter: Invalid timestamp\\\");\\n        require(answeredInRound >= _roundId, \\\"ChainlinkAdapter: Stale price (round mismatch)\\\");\\n\\n        // Staleness check\\n        require(\\n            block.timestamp - updatedAt <= feed.heartbeat,\\n            \\\"ChainlinkAdapter: Price too stale\\\"\\n        );\\n\\n        // Normalize to 18 decimals (Chainlink uses 8)\\n        uint256 normalizedPrice = uint256(answer) * 1e10;\\n\\n        return (normalizedPrice, updatedAt, _roundId);\\n    }\\n\\n    /// @notice Get price from specific historical round\\n    /// @dev Used for dispute resolution (verify historical claim)\\n    /// @param pairId Asset pair identifier\\n    /// @param roundId Historical round ID to query\\n    /// @return price Historical price (normalized to 18 decimals)\\n    /// @return timestamp When that round was finalized\\n    function getHistoricalPrice(bytes32 pairId, uint80 roundId)\\n        external\\n        view\\n        returns (\\n            uint256 price,\\n            uint256 timestamp\\n        )\\n    {\\n        PriceFeed memory feed = priceFeeds[pairId];\\n        require(address(feed.feed) != address(0), \\\"ChainlinkAdapter: Feed not registered\\\");\\n\\n        (\\n            ,\\n            int256 answer,\\n            ,\\n            uint256 updatedAt,\\n            uint80 answeredInRound\\n        ) = feed.feed.getRoundData(roundId);\\n\\n        require(answer > 0, \\\"ChainlinkAdapter: Invalid historical price\\\");\\n        require(answeredInRound == roundId, \\\"ChainlinkAdapter: Round not finalized\\\");\\n\\n        uint256 normalizedPrice = uint256(answer) * 1e10;\\n        return (normalizedPrice, updatedAt);\\n    }\\n\\n    /// @notice Check if a feed is registered\\n    /// @param pairId Asset pair to check\\n    /// @return True if feed exists\\n    function isFeedRegistered(bytes32 pairId) external view returns (bool) {\\n        return address(priceFeeds[pairId].feed) != address(0);\\n    }\\n\\n    /// @notice Get feed information\\n    /// @param pairId Asset pair to query\\n    /// @return feedAddress Chainlink aggregator address\\n    /// @return decimals Feed decimals\\n    /// @return description Feed description\\n    /// @return heartbeat Max staleness in seconds\\n    function getFeedInfo(bytes32 pairId)\\n        external\\n        view\\n        returns (\\n            address feedAddress,\\n            uint8 decimals,\\n            string memory description,\\n            uint256 heartbeat\\n        )\\n    {\\n        PriceFeed memory feed = priceFeeds[pairId];\\n        return (\\n            address(feed.feed),\\n            feed.decimals,\\n            feed.description,\\n            feed.heartbeat\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xe290a0dcaf42515f9bc0e444a6adfb80488c784699ab7f75853117c944ce0bd5\",\"license\":\"MIT\"},\"contracts/oracles/OracleAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ChainlinkOracleAdapter.sol\\\";\\nimport \\\"./PythOracleAdapter.sol\\\";\\nimport \\\"./UniswapV3TWAPAdapter.sol\\\";\\n\\n/// @title OracleAggregator\\n/// @notice Aggregates 3 oracle sources with Byzantine fault tolerance\\n/// @dev Handles: conflicting values, staleness, 30% manipulation, missing updates\\n/// @dev Byzantine-resistant: 2/3 honest oracles ensure correct median price\\ncontract OracleAggregator {\\n\\n    ChainlinkOracleAdapter public chainlink;\\n    PythOracleAdapter public pyth;\\n    UniswapV3TWAPAdapter public uniswapTWAP;\\n\\n    struct AggregatedPrice {\\n        uint256 price;           // Median price from all sources\\n        uint256 timestamp;       // Earliest timestamp among sources\\n        uint256 confidence;      // Confidence score (0-100)\\n        uint256 deviation;       // Max deviation between sources (basis points)\\n        uint8 sourceCount;       // Number of oracles that responded\\n        bool isHealthy;          // True if passes all checks\\n        string[] activeSources;  // Which oracles contributed\\n    }\\n\\n    struct OracleReading {\\n        uint256 price;\\n        uint256 timestamp;\\n        bool success;\\n        string source;\\n    }\\n\\n    // Thresholds (from adversarial conditions)\\n    uint256 public constant MAX_ACCEPTABLE_DEVIATION = 3000; // 30% (handles adversarial condition #1)\\n    uint256 public constant MIN_SOURCES_REQUIRED = 2;        // Need at least 2 oracles (Byzantine tolerance)\\n    uint256 public constant MAX_PRICE_AGE = 3600;            // 1 hour staleness limit (handles condition #2)\\n\\n    event OraclePriceFetched(string source, uint256 price, uint256 timestamp);\\n    event OracleFetchFailed(string source, string reason);\\n    event PriceAggregated(\\n        bytes32 indexed pairId,\\n        uint256 medianPrice,\\n        uint8 sourceCount,\\n        uint256 deviation,\\n        bool isHealthy\\n    );\\n\\n    constructor(\\n        address _chainlink,\\n        address _pyth,\\n        address _uniswapTWAP\\n    ) {\\n        require(_chainlink != address(0), \\\"OracleAggregator: Invalid Chainlink address\\\");\\n        require(_pyth != address(0), \\\"OracleAggregator: Invalid Pyth address\\\");\\n        require(_uniswapTWAP != address(0), \\\"OracleAggregator: Invalid Uniswap address\\\");\\n\\n        chainlink = ChainlinkOracleAdapter(_chainlink);\\n        pyth = PythOracleAdapter(_pyth);\\n        uniswapTWAP = UniswapV3TWAPAdapter(_uniswapTWAP);\\n    }\\n\\n    /// @notice Get aggregated price from all oracle sources\\n    /// @dev Handles all 4 adversarial conditions from hackathon spec\\n    /// @param pairId Asset pair (e.g., keccak256(\\\"ETH/USD\\\"))\\n    /// @return Aggregated price data with health metrics\\n    function getAggregatedPrice(bytes32 pairId)\\n        public\\n        returns (AggregatedPrice memory)\\n    {\\n        OracleReading[] memory readings = new OracleReading[](3);\\n        uint8 successCount = 0;\\n\\n        // 1. Fetch from Chainlink (most decentralized, slowest updates)\\n        try chainlink.getLatestPrice(pairId) returns (\\n            uint256 price,\\n            uint256 timestamp,\\n            uint80 /* roundId */\\n        ) {\\n            readings[successCount++] = OracleReading({\\n                price: price,\\n                timestamp: timestamp,\\n                success: true,\\n                source: \\\"Chainlink\\\"\\n            });\\n            emit OraclePriceFetched(\\\"Chainlink\\\", price, timestamp);\\n        } catch Error(string memory reason) {\\n            emit OracleFetchFailed(\\\"Chainlink\\\", reason);\\n        } catch {\\n            emit OracleFetchFailed(\\\"Chainlink\\\", \\\"Unknown error\\\");\\n        }\\n\\n        // 2. Fetch from Pyth (high-frequency, sub-second updates)\\n        try pyth.getLatestPrice(pairId) returns (\\n            uint256 price,\\n            uint256 timestamp,\\n            uint64 /* conf */\\n        ) {\\n            readings[successCount++] = OracleReading({\\n                price: price,\\n                timestamp: timestamp,\\n                success: true,\\n                source: \\\"Pyth\\\"\\n            });\\n            emit OraclePriceFetched(\\\"Pyth\\\", price, timestamp);\\n        } catch Error(string memory reason) {\\n            emit OracleFetchFailed(\\\"Pyth\\\", reason);\\n        } catch {\\n            emit OracleFetchFailed(\\\"Pyth\\\", \\\"Unknown error\\\");\\n        }\\n\\n        // 3. Fetch from Uniswap V3 TWAP (on-chain, manipulation-resistant)\\n        try uniswapTWAP.getLatestPrice(pairId) returns (\\n            uint256 price,\\n            uint256 timestamp\\n        ) {\\n            readings[successCount++] = OracleReading({\\n                price: price,\\n                timestamp: timestamp,\\n                success: true,\\n                source: \\\"Uniswap TWAP\\\"\\n            });\\n            emit OraclePriceFetched(\\\"Uniswap TWAP\\\", price, timestamp);\\n        } catch Error(string memory reason) {\\n            emit OracleFetchFailed(\\\"Uniswap TWAP\\\", reason);\\n        } catch {\\n            emit OracleFetchFailed(\\\"Uniswap TWAP\\\", \\\"Unknown error\\\");\\n        }\\n\\n        // ADVERSARIAL CONDITION #3: Handle missing updates\\n        // Require at least 2 oracles working (can tolerate 1 failure)\\n        require(successCount >= MIN_SOURCES_REQUIRED, \\\"OracleAggregator: Insufficient oracle sources\\\");\\n\\n        // Aggregate results\\n        AggregatedPrice memory result = _aggregateReadings(readings, successCount);\\n\\n        emit PriceAggregated(\\n            pairId,\\n            result.price,\\n            result.sourceCount,\\n            result.deviation,\\n            result.isHealthy\\n        );\\n\\n        return result;\\n    }\\n\\n    /// @notice Aggregate multiple oracle readings into single price\\n    /// @dev Uses median for Byzantine fault tolerance (resistant to 1 malicious oracle)\\n    /// @param readings Array of oracle readings\\n    /// @param count Number of successful readings\\n    /// @return Aggregated price with health metrics\\n    function _aggregateReadings(\\n        OracleReading[] memory readings,\\n        uint8 count\\n    ) internal view returns (AggregatedPrice memory) {\\n        require(count >= MIN_SOURCES_REQUIRED, \\\"OracleAggregator: Too few sources\\\");\\n\\n        // Extract successful readings\\n        uint256[] memory prices = new uint256[](count);\\n        uint256[] memory timestamps = new uint256[](count);\\n        string[] memory sources = new string[](count);\\n\\n        for (uint8 i = 0; i < count; i++) {\\n            prices[i] = readings[i].price;\\n            timestamps[i] = readings[i].timestamp;\\n            sources[i] = readings[i].source;\\n        }\\n\\n        // Sort prices for median calculation\\n        if (count > 1) {\\n            _quickSort(prices, 0, int256(uint256(count - 1)));\\n        }\\n\\n        // Calculate median (Byzantine-resistant: correct if 2/3 honest)\\n        // ADVERSARIAL CONDITION #1: Even if 1 oracle reports 30%+ wrong price, median is correct\\n        uint256 medianPrice;\\n        if (count % 2 == 0) {\\n            // Even number: average of middle two\\n            medianPrice = (prices[count / 2 - 1] + prices[count / 2]) / 2;\\n        } else {\\n            // Odd number: middle value\\n            medianPrice = prices[count / 2];\\n        }\\n\\n        // Calculate deviation (detect conflicting values)\\n        // ADVERSARIAL CONDITION #4: Detect when oracles provide conflicting values\\n        uint256 minPrice = prices[0];\\n        uint256 maxPrice = prices[count - 1];\\n        uint256 deviation = ((maxPrice - minPrice) * 10000) / medianPrice;\\n\\n        // Calculate confidence (inverse of deviation, scaled 0-100)\\n        uint256 confidence = deviation < 10000 ? 10000 - deviation : 0;\\n        confidence = (confidence * 100) / 10000;\\n\\n        // Find earliest timestamp (conservative staleness check)\\n        // ADVERSARIAL CONDITION #2: Use most conservative timestamp\\n        uint256 earliestTimestamp = timestamps[0];\\n        for (uint8 i = 1; i < count; i++) {\\n            if (timestamps[i] < earliestTimestamp) {\\n                earliestTimestamp = timestamps[i];\\n            }\\n        }\\n\\n        // Health checks\\n        bool isHealthy = true;\\n\\n        // Check 1: Deviation within acceptable range (30%)\\n        if (deviation > MAX_ACCEPTABLE_DEVIATION) {\\n            isHealthy = false; // Conflicting values detected (CONDITION #4)\\n        }\\n\\n        // Check 2: Not too stale\\n        if (block.timestamp - earliestTimestamp > MAX_PRICE_AGE) {\\n            isHealthy = false; // Outdated data (CONDITION #2)\\n        }\\n\\n        // Check 3: Minimum confidence threshold\\n        if (confidence < 50) {\\n            isHealthy = false; // Low confidence\\n        }\\n\\n        return AggregatedPrice({\\n            price: medianPrice,\\n            timestamp: earliestTimestamp,\\n            confidence: confidence,\\n            deviation: deviation,\\n            sourceCount: count,\\n            isHealthy: isHealthy,\\n            activeSources: sources\\n        });\\n    }\\n\\n    /// @notice Quick sort for median calculation (ascending order)\\n    /// @dev O(n log n) average case, used for sorting prices\\n    /// @param arr Array to sort (modified in-place)\\n    /// @param left Left boundary\\n    /// @param right Right boundary\\n    function _quickSort(uint256[] memory arr, int256 left, int256 right) internal pure {\\n        if (left >= right) return;\\n\\n        int256 i = left;\\n        int256 j = right;\\n        uint256 pivot = arr[uint256(left + (right - left) / 2)];\\n\\n        while (i <= j) {\\n            while (arr[uint256(i)] < pivot) i++;\\n            while (pivot < arr[uint256(j)]) j--;\\n            if (i <= j) {\\n                (arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\\n                i++;\\n                j--;\\n            }\\n        }\\n\\n        if (left < j) _quickSort(arr, left, j);\\n        if (i < right) _quickSort(arr, i, right);\\n    }\\n\\n    /// @notice Verify if a claimed price is reasonable given current oracle state\\n    /// @dev Used in dispute resolution - checks against all 4 adversarial conditions\\n    /// @param pairId Asset pair\\n    /// @param claimedPrice Price submitted by prover\\n    /// @param claimTimestamp When price was claimed\\n    /// @return isValid True if claim passes verification\\n    /// @return reason Explanation of result\\n    function verifyClaimedPrice(\\n        bytes32 pairId,\\n        uint256 claimedPrice,\\n        uint256 claimTimestamp\\n    ) external returns (bool isValid, string memory reason) {\\n        AggregatedPrice memory agg = getAggregatedPrice(pairId);\\n\\n        // Check 1: Claimed price within 30% of aggregated median (CONDITION #1)\\n        uint256 priceDeviation = claimedPrice > agg.price\\n            ? ((claimedPrice - agg.price) * 10000) / agg.price\\n            : ((agg.price - claimedPrice) * 10000) / agg.price;\\n\\n        if (priceDeviation > MAX_ACCEPTABLE_DEVIATION) {\\n            return (false, \\\"Claimed price deviates >30% from oracle consensus\\\");\\n        }\\n\\n        // Check 2: Oracle data is healthy (CONDITION #2, #4)\\n        if (!agg.isHealthy) {\\n            return (false, \\\"Oracle data unhealthy - conflicting or stale\\\");\\n        }\\n\\n        // Check 3: Timestamp reasonable (CONDITION #2)\\n        if (claimTimestamp > block.timestamp) {\\n            return (false, \\\"Claimed timestamp in future\\\");\\n        }\\n\\n        if (block.timestamp - claimTimestamp > MAX_PRICE_AGE) {\\n            return (false, \\\"Claimed price too old\\\");\\n        }\\n\\n        return (true, \\\"Price verified by oracle consensus\\\");\\n    }\\n\\n    /// @notice Get individual oracle prices for transparency\\n    /// @dev Useful for debugging and showing which oracle is outlier\\n    /// @param pairId Asset pair\\n    /// @return chainlinkPrice Price from Chainlink\\n    /// @return pythPrice Price from Pyth\\n    /// @return uniswapPrice Price from Uniswap TWAP\\n    /// @return chainlinkSuccess True if Chainlink succeeded\\n    /// @return pythSuccess True if Pyth succeeded\\n    /// @return uniswapSuccess True if Uniswap succeeded\\n    function getIndividualPrices(bytes32 pairId)\\n        external\\n        view\\n        returns (\\n            uint256 chainlinkPrice,\\n            uint256 pythPrice,\\n            uint256 uniswapPrice,\\n            bool chainlinkSuccess,\\n            bool pythSuccess,\\n            bool uniswapSuccess\\n        )\\n    {\\n        // Fetch Chainlink\\n        try chainlink.getLatestPrice(pairId) returns (\\n            uint256 price,\\n            uint256,\\n            uint80\\n        ) {\\n            chainlinkPrice = price;\\n            chainlinkSuccess = true;\\n        } catch {\\n            chainlinkSuccess = false;\\n        }\\n\\n        // Fetch Pyth\\n        try pyth.getLatestPrice(pairId) returns (\\n            uint256 price,\\n            uint256,\\n            uint64\\n        ) {\\n            pythPrice = price;\\n            pythSuccess = true;\\n        } catch {\\n            pythSuccess = false;\\n        }\\n\\n        // Fetch Uniswap TWAP\\n        try uniswapTWAP.getLatestPrice(pairId) returns (\\n            uint256 price,\\n            uint256\\n        ) {\\n            uniswapPrice = price;\\n            uniswapSuccess = true;\\n        } catch {\\n            uniswapSuccess = false;\\n        }\\n    }\\n\\n    /// @notice Emergency: Get price even if unhealthy (with explicit warnings)\\n    /// @dev Only use when system must proceed despite oracle issues\\n    /// @param pairId Asset pair\\n    /// @return price Median price (may be unreliable)\\n    /// @return warning Explicit warning message\\n    function getEmergencyPrice(bytes32 pairId)\\n        external\\n        returns (uint256 price, string memory warning)\\n    {\\n        AggregatedPrice memory agg = getAggregatedPrice(pairId);\\n\\n        if (!agg.isHealthy) {\\n            if (agg.deviation > MAX_ACCEPTABLE_DEVIATION) {\\n                warning = \\\"WARNING: Oracle sources conflict >30% - using median with HIGH UNCERTAINTY\\\";\\n            } else if (block.timestamp - agg.timestamp > MAX_PRICE_AGE) {\\n                warning = \\\"WARNING: Oracle data stale - price may not reflect current market\\\";\\n            } else {\\n                warning = \\\"WARNING: Low confidence in oracle data\\\";\\n            }\\n        } else {\\n            warning = \\\"\\\";\\n        }\\n\\n        return (agg.price, warning);\\n    }\\n}\\n\",\"keccak256\":\"0xf2f78695d34c6320a912c1f249ff495e9d4f25ec5023fd9e4e9db93ea37017f8\",\"license\":\"MIT\"},\"contracts/oracles/PythOracleAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@pythnetwork/pyth-sdk-solidity/IPyth.sol\\\";\\nimport \\\"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\\\";\\n\\n/// @title PythOracleAdapter\\n/// @notice Fetches price data from Pyth Network (high-frequency oracle)\\n/// @dev Official Sepolia testnet address from https://docs.pyth.network/price-feeds/contract-addresses/evm\\ncontract PythOracleAdapter {\\n\\n    IPyth public pyth;\\n\\n    // Pyth contract address (Ethereum Sepolia testnet)\\n    // Source: https://docs.pyth.network/price-feeds/contract-addresses/evm\\n    address public constant PYTH_ADDRESS = 0xDd24F84d36BF92C65F92307595335bdFab5Bbd21;\\n\\n    // Price feed IDs (Pyth identifiers)\\n    // Source: https://pyth.network/developers/price-feed-ids\\n    bytes32 public constant ETH_USD_FEED_ID =\\n        0xff61491a931112ddf1bd8147cd1b641375f79f5825126d665480874634fd0ace;\\n    bytes32 public constant BTC_USD_FEED_ID =\\n        0xe62df6c8b4a85fe1a67db44dc12de5db330f7ac66b72dc658afedf0f4a415b43;\\n\\n    mapping(bytes32 => bytes32) public feedIds; // pairId => Pyth feed ID\\n\\n    event PriceFeedRegistered(bytes32 indexed pairId, bytes32 indexed feedId);\\n    event PriceFetched(bytes32 indexed pairId, uint256 price, uint256 timestamp, uint64 conf);\\n\\n    constructor() {\\n        pyth = IPyth(PYTH_ADDRESS);\\n\\n        // Register ETH/USD\\n        feedIds[keccak256(\\\"ETH/USD\\\")] = ETH_USD_FEED_ID;\\n        emit PriceFeedRegistered(keccak256(\\\"ETH/USD\\\"), ETH_USD_FEED_ID);\\n\\n        // Register BTC/USD\\n        feedIds[keccak256(\\\"BTC/USD\\\")] = BTC_USD_FEED_ID;\\n        emit PriceFeedRegistered(keccak256(\\\"BTC/USD\\\"), BTC_USD_FEED_ID);\\n    }\\n\\n    /// @notice Get latest price from Pyth (normalized to 18 decimals)\\n    /// @param pairId Asset pair identifier (e.g., keccak256(\\\"ETH/USD\\\"))\\n    /// @return price Normalized price (18 decimals)\\n    /// @return timestamp Publish time\\n    /// @return conf Confidence interval\\n    function getLatestPrice(bytes32 pairId)\\n        external\\n        view\\n        returns (\\n            uint256 price,\\n            uint256 timestamp,\\n            uint64 conf\\n        )\\n    {\\n        bytes32 feedId = feedIds[pairId];\\n        require(feedId != bytes32(0), \\\"PythAdapter: Feed not registered\\\");\\n\\n        PythStructs.Price memory priceData = pyth.getPriceUnsafe(feedId);\\n\\n        // Validation\\n        require(priceData.price > 0, \\\"PythAdapter: Invalid price\\\");\\n        require(priceData.publishTime > 0, \\\"PythAdapter: Invalid timestamp\\\");\\n\\n        // Staleness check (Pyth updates every 400ms, allow 60s max)\\n        require(\\n            block.timestamp - priceData.publishTime <= 60,\\n            \\\"PythAdapter: Pyth price too stale\\\"\\n        );\\n\\n        // Normalize to 18 decimals\\n        uint256 normalizedPrice = _normalizePrice(\\n            uint64(priceData.price),\\n            priceData.expo\\n        );\\n\\n        return (normalizedPrice, priceData.publishTime, priceData.conf);\\n    }\\n\\n    /// @notice Normalize Pyth price to 18 decimals\\n    /// @dev Pyth prices come with exponent (e.g., price=3000, expo=-8 means $30.00)\\n    /// @param price Raw price value\\n    /// @param expo Exponent (negative for decimal places)\\n    /// @return Normalized price with 18 decimals\\n    function _normalizePrice(uint64 price, int32 expo) internal pure returns (uint256) {\\n        // Pyth prices: price * 10^expo\\n        // Target: 18 decimals\\n\\n        if (expo < 0) {\\n            uint32 absExpo = uint32(-expo);\\n            if (absExpo < 18) {\\n                // Scale up to 18 decimals\\n                return uint256(price) * (10 ** (18 - absExpo));\\n            } else {\\n                // Already more than 18 decimals, scale down\\n                return uint256(price) / (10 ** (absExpo - 18));\\n            }\\n        } else {\\n            // Positive exponent (rare)\\n            return uint256(price) * (10 ** (18 + uint32(expo)));\\n        }\\n    }\\n\\n    /// @notice Update Pyth price with off-chain data\\n    /// @dev Pyth requires price update data from Hermes API\\n    /// @param priceUpdateData Price update data from Pyth Hermes\\n    function updatePrice(bytes[] calldata priceUpdateData)\\n        external\\n        payable\\n    {\\n        uint256 fee = pyth.getUpdateFee(priceUpdateData);\\n        require(msg.value >= fee, \\\"PythAdapter: Insufficient update fee\\\");\\n\\n        pyth.updatePriceFeeds{value: fee}(priceUpdateData);\\n    }\\n\\n    /// @notice Get Pyth price without safety checks (unsafe - use with caution)\\n    /// @dev Only use this if you need raw data and handle validation yourself\\n    /// @param pairId Asset pair identifier\\n    /// @return priceData Raw Pyth price struct\\n    function getPriceUnsafe(bytes32 pairId)\\n        external\\n        view\\n        returns (PythStructs.Price memory priceData)\\n    {\\n        bytes32 feedId = feedIds[pairId];\\n        require(feedId != bytes32(0), \\\"PythAdapter: Feed not registered\\\");\\n\\n        return pyth.getPriceUnsafe(feedId);\\n    }\\n\\n    /// @notice Get the current update fee for Pyth\\n    /// @param updateDataSize Number of price updates\\n    /// @return fee Required fee in wei\\n    function getUpdateFee(uint256 updateDataSize) external view returns (uint256) {\\n        bytes[] memory dummyData = new bytes[](updateDataSize);\\n        return pyth.getUpdateFee(dummyData);\\n    }\\n\\n    /// @notice Check if feed is registered\\n    /// @param pairId Asset pair to check\\n    /// @return True if feed registered\\n    function isFeedRegistered(bytes32 pairId) external view returns (bool) {\\n        return feedIds[pairId] != bytes32(0);\\n    }\\n}\\n\",\"keccak256\":\"0xc135b1040d9189d3cb6ce2c0238c7574d29964250a429fd3df03f130c722119c\",\"license\":\"MIT\"},\"contracts/oracles/UniswapV3TWAPAdapter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol\\\";\\n\\n/// @title UniswapV3TWAPAdapter\\n/// @notice Fetches time-weighted average price from Uniswap V3 pools\\n/// @dev Provides on-chain price oracle resistant to flash loan manipulation\\n/// @dev Pool addresses from https://www.geckoterminal.com/sepolia-testnet\\ncontract UniswapV3TWAPAdapter {\\n\\n    struct PoolConfig {\\n        address pool;\\n        address baseToken;  // Token being priced (e.g., WETH)\\n        address quoteToken; // Token price is quoted in (e.g., USDC)\\n        uint8 baseDecimals;\\n        uint8 quoteDecimals;\\n        uint32 twapPeriod;  // Time window for TWAP (seconds)\\n        bool isToken0Base;  // True if baseToken is token0 in the pool\\n    }\\n\\n    mapping(bytes32 => PoolConfig) public pools;\\n\\n    // Uniswap V3 pool addresses (Sepolia testnet)\\n    // Source: https://www.geckoterminal.com/sepolia-testnet/pools/0x9799b5edc1aa7d3fad350309b08df3f64914e244\\n    address public constant USDC_WETH_POOL_03 = 0x9799b5EDC1aA7D3FAd350309B08df3F64914E244; // 0.3% fee\\n\\n    // Token addresses on Sepolia (need to verify these)\\n    address public constant WETH = 0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14; // WETH on Sepolia\\n    address public constant USDC = 0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238; // USDC on Sepolia\\n\\n    event PoolRegistered(bytes32 indexed pairId, address poolAddress, uint32 twapPeriod);\\n    event TWAPCalculated(bytes32 indexed pairId, uint256 price, uint256 timestamp);\\n\\n    constructor() {\\n        // Register WETH/USDC pool\\n        // Note: This gives price of WETH in USDC, we map it to ETH/USD\\n        pools[keccak256(\\\"ETH/USD\\\")] = PoolConfig({\\n            pool: USDC_WETH_POOL_03,\\n            baseToken: WETH,\\n            quoteToken: USDC,\\n            baseDecimals: 18,  // WETH has 18 decimals\\n            quoteDecimals: 6,  // USDC has 6 decimals\\n            twapPeriod: 1800,  // 30 minute TWAP (balance between freshness and security)\\n            isToken0Base: false // WETH is typically token1, USDC is token0 (lower address)\\n        });\\n\\n        emit PoolRegistered(keccak256(\\\"ETH/USD\\\"), USDC_WETH_POOL_03, 1800);\\n    }\\n\\n    /// @notice Get time-weighted average price from Uniswap V3\\n    /// @param pairId Asset pair identifier (e.g., keccak256(\\\"ETH/USD\\\"))\\n    /// @return price TWAP price (normalized to 18 decimals)\\n    /// @return timestamp Current block timestamp (TWAP is current)\\n    function getLatestPrice(bytes32 pairId)\\n        external\\n        view\\n        returns (\\n            uint256 price,\\n            uint256 timestamp\\n        )\\n    {\\n        PoolConfig memory config = pools[pairId];\\n        require(config.pool != address(0), \\\"UniswapAdapter: Pool not configured\\\");\\n\\n        IUniswapV3Pool pool = IUniswapV3Pool(config.pool);\\n\\n        // Get TWAP tick (arithmetic mean over the period)\\n        int24 arithmeticMeanTick = _getTWAPTick(pool, config.twapPeriod);\\n\\n        // Convert tick to price\\n        uint256 quoteAmount = _getQuoteAtTick(\\n            arithmeticMeanTick,\\n            uint128(10 ** config.baseDecimals), // 1 unit of base token (e.g., 1 WETH)\\n            config.isToken0Base\\n        );\\n\\n        // Normalize to 18 decimals\\n        uint256 normalizedPrice;\\n        if (config.quoteDecimals < 18) {\\n            // Scale up (e.g., USDC has 6 decimals, multiply by 10^12)\\n            normalizedPrice = quoteAmount * (10 ** (18 - config.quoteDecimals));\\n        } else {\\n            // Scale down (rare case)\\n            normalizedPrice = quoteAmount / (10 ** (config.quoteDecimals - 18));\\n        }\\n\\n        return (normalizedPrice, block.timestamp);\\n    }\\n\\n    /// @notice Calculate TWAP tick from Uniswap V3 pool observations\\n    /// @dev Queries pool's oracle observations and calculates arithmetic mean tick\\n    /// @param pool Uniswap V3 pool contract\\n    /// @param period TWAP period in seconds\\n    /// @return arithmeticMeanTick The time-weighted average tick\\n    function _getTWAPTick(IUniswapV3Pool pool, uint32 period)\\n        internal\\n        view\\n        returns (int24 arithmeticMeanTick)\\n    {\\n        uint32[] memory secondsAgos = new uint32[](2);\\n        secondsAgos[0] = period; // Start of TWAP window\\n        secondsAgos[1] = 0;      // Current time\\n\\n        // Get cumulative tick data from pool\\n        (int56[] memory tickCumulatives, ) = pool.observe(secondsAgos);\\n\\n        // Calculate arithmetic mean tick over the period\\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\\n        arithmeticMeanTick = int24(tickCumulativesDelta / int56(uint56(period)));\\n\\n        // Round down for negative ticks\\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(period)) != 0)) {\\n            arithmeticMeanTick--;\\n        }\\n    }\\n\\n    /// @notice Convert Uniswap V3 tick to quote amount\\n    /// @dev Simplified version of OracleLibrary.getQuoteAtTick for Solidity 0.8\\n    /// @param tick The tick to convert\\n    /// @param baseAmount Amount of base token (with decimals)\\n    /// @param isToken0Base True if base token is token0\\n    /// @return quoteAmount The corresponding amount of quote token\\n    function _getQuoteAtTick(\\n        int24 tick,\\n        uint128 baseAmount,\\n        bool isToken0Base\\n    ) internal pure returns (uint256 quoteAmount) {\\n        // Get sqrtPrice from tick\\n        uint160 sqrtPriceX96 = _getSqrtRatioAtTick(tick);\\n\\n        // Calculate price from sqrtPriceX96\\n        // sqrtPriceX96 = sqrt(token1/token0) * 2^96\\n        // price = (sqrtPriceX96 / 2^96)^2\\n\\n        if (sqrtPriceX96 <= type(uint128).max) {\\n            uint256 priceX192 = uint256(sqrtPriceX96) * sqrtPriceX96;\\n            quoteAmount = isToken0Base\\n                ? _mulDiv(priceX192, baseAmount, 1 << 192)\\n                : _mulDiv(1 << 192, baseAmount, priceX192);\\n        } else {\\n            uint256 priceX128 = _mulDiv(sqrtPriceX96, sqrtPriceX96, 1 << 64);\\n            quoteAmount = isToken0Base\\n                ? _mulDiv(priceX128, baseAmount, 1 << 128)\\n                : _mulDiv(1 << 128, baseAmount, priceX128);\\n        }\\n    }\\n\\n    /// @notice Get sqrtPriceX96 from tick\\n    /// @dev Simplified implementation for common tick ranges\\n    /// @param tick The tick to convert\\n    /// @return sqrtPriceX96 The sqrt price encoded as a Q64.96\\n    function _getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n        require(absTick <= uint256(int256(type(int24).max)), \\\"T\\\");\\n\\n        uint256 ratio = absTick & 0x1 != 0\\n            ? 0xfffcb933bd6fad37aa2d162d1a594001\\n            : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n    }\\n\\n    /// @notice Full precision multiplication\\n    /// @dev Calculates floor(a\\u00d7b\\u00f7denominator) with full precision\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function _mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        uint256 prod0;\\n        uint256 prod1;\\n        assembly {\\n            let mm := mulmod(a, b, not(0))\\n            prod0 := mul(a, b)\\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n        }\\n\\n        if (prod1 == 0) {\\n            require(denominator > 0);\\n            assembly {\\n                result := div(prod0, denominator)\\n            }\\n            return result;\\n        }\\n\\n        require(denominator > prod1);\\n\\n        uint256 remainder;\\n        assembly {\\n            remainder := mulmod(a, b, denominator)\\n        }\\n        assembly {\\n            prod1 := sub(prod1, gt(remainder, prod0))\\n            prod0 := sub(prod0, remainder)\\n        }\\n\\n        uint256 twos = denominator & (~denominator + 1);\\n        assembly {\\n            denominator := div(denominator, twos)\\n        }\\n\\n        assembly {\\n            prod0 := div(prod0, twos)\\n        }\\n        assembly {\\n            twos := add(div(sub(0, twos), twos), 1)\\n        }\\n        prod0 |= prod1 * twos;\\n\\n        uint256 inv = (3 * denominator) ^ 2;\\n        inv *= 2 - denominator * inv;\\n        inv *= 2 - denominator * inv;\\n        inv *= 2 - denominator * inv;\\n        inv *= 2 - denominator * inv;\\n        inv *= 2 - denominator * inv;\\n        inv *= 2 - denominator * inv;\\n\\n        result = prod0 * inv;\\n        return result;\\n    }\\n\\n    /// @notice Check if pool has sufficient history for TWAP\\n    /// @dev Verifies pool has observations covering the TWAP period\\n    /// @param pairId Asset pair to check\\n    /// @return True if pool is healthy and has sufficient data\\n    function isPoolHealthy(bytes32 pairId) external view returns (bool) {\\n        PoolConfig memory config = pools[pairId];\\n        if (config.pool == address(0)) return false;\\n\\n        IUniswapV3Pool pool = IUniswapV3Pool(config.pool);\\n\\n        uint32[] memory secondsAgos = new uint32[](2);\\n        secondsAgos[0] = config.twapPeriod;\\n        secondsAgos[1] = 0;\\n\\n        // Check if pool has observations for TWAP period\\n        try pool.observe(secondsAgos) returns (\\n            int56[] memory,\\n            uint160[] memory\\n        ) {\\n            return true;\\n        } catch {\\n            return false;\\n        }\\n    }\\n\\n    /// @notice Get pool configuration\\n    /// @param pairId Asset pair to query\\n    /// @return config Pool configuration struct\\n    function getPoolConfig(bytes32 pairId) external view returns (PoolConfig memory) {\\n        return pools[pairId];\\n    }\\n\\n    /// @notice Check if pool is registered\\n    /// @param pairId Asset pair to check\\n    /// @return True if pool registered\\n    function isPoolRegistered(bytes32 pairId) external view returns (bool) {\\n        return pools[pairId].pool != address(0);\\n    }\\n}\\n\",\"keccak256\":\"0x32e1cf24c9783cdaed79468d034d1d9658eb9ee178bcff6da4460dfdcc4fc09c\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b5060405162001cac38038062001cac8339810160408190526200003491620001d5565b6001600160a01b038316620000a45760405162461bcd60e51b815260206004820152602b60248201527f4f7261636c6541676772656761746f723a20496e76616c696420436861696e6c60448201526a696e6b206164647265737360a81b60648201526084015b60405180910390fd5b6001600160a01b0382166200010b5760405162461bcd60e51b815260206004820152602660248201527f4f7261636c6541676772656761746f723a20496e76616c69642050797468206160448201526564647265737360d01b60648201526084016200009b565b6001600160a01b038116620001755760405162461bcd60e51b815260206004820152602960248201527f4f7261636c6541676772656761746f723a20496e76616c696420556e6973776160448201526870206164647265737360b81b60648201526084016200009b565b600080546001600160a01b039485166001600160a01b0319918216179091556001805493851693821693909317909255600280549190931691161790556200021f565b80516001600160a01b0381168114620001d057600080fd5b919050565b600080600060608486031215620001eb57600080fd5b620001f684620001b8565b92506200020660208501620001b8565b91506200021660408501620001b8565b90509250925092565b611a7d806200022f6000396000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c80639c3feeb7116100665780639c3feeb71461016a5780639d7f7e8614610195578063bdbde1f41461019e578063d8a0a352146101a7578063f98d06f0146101ba57600080fd5b806301dee057146100a35780631fde7f26146100cd57806327d69475146100ed5780632ee2f1281461010e5780639a321e3d14610124575b600080fd5b6100b66100b1366004611259565b6101cd565b6040516100c49291906112cb565b60405180910390f35b6100e06100db3660046112ee565b610358565b6040516100c49190611307565b6101006100fb3660046112ee565b610992565b6040516100c49291906113b8565b610116600281565b6040519081526020016100c4565b6101376101323660046112ee565b610a4f565b604080519687526020870195909552938501929092521515606084015215156080830152151560a082015260c0016100c4565b60005461017d906001600160a01b031681565b6040516001600160a01b0390911681526020016100c4565b610116610e1081565b610116610bb881565b60025461017d906001600160a01b031681565b60015461017d906001600160a01b031681565b6000606060006101dc86610358565b90506000816000015186116102125781516101f787826113e7565b610203906127106113fa565b61020d9190611427565b610234565b815161021e81886113e7565b61022a906127106113fa565b6102349190611427565b9050610bb88111156102665760006040518060600160405280603181526020016119f560319139935093505050610350565b8160a001516102955760006040518060600160405280602c8152602001611959602c9139935093505050610350565b428511156102e05760006040518060400160405280601b81526020017f436c61696d65642074696d657374616d7020696e206675747572650000000000815250935093505050610350565b610e106102ed86426113e7565b111561032e5760006040518060400160405280601581526020017410db185a5b5959081c1c9a58d9481d1bdbc81bdb19605a1b815250935093505050610350565b6001604051806060016040528060228152602001611a26602291399350935050505b935093915050565b61039d6040518060e0016040528060008152602001600081526020016000815260200160008152602001600060ff168152602001600015158152602001606081525090565b60408051600380825260808201909252600091816020015b6103e260405180608001604052806000815260200160008152602001600015158152602001606081525090565b8152602001906001900390816103b5579050506000805460405163b2ee2f0160e01b81526004810187905292935090916001600160a01b039091169063b2ee2f0190602401606060405180830381865afa925050508015610460575060408051601f3d908101601f1916820190925261045d91810190611451565b60015b6104e05761046c611499565b806308c379a0036104b657506104806114f0565b8061048b57506104b8565b600080516020611939833981519152816040516104a8919061157a565b60405180910390a15061058e565b505b6000805160206119398339815191526040516104d3906115b5565b60405180910390a161058e565b604051806080016040528084815260200183815260200160011515815260200160405180604001604052806009815260200168436861696e6c696e6b60b81b81525081525085858061053190611611565b965060ff168151811061054657610546611630565b60200260200101819052507f14291c3647547e7abe3197b5c24b2b24317b6b49fde545229aa990e119915cac8383604051610582929190611646565b60405180910390a15050505b60015460405163b2ee2f0160e01b8152600481018690526001600160a01b039091169063b2ee2f0190602401606060405180830381865afa9250505080156105f3575060408051601f3d908101601f191682019092526105f09181019061167f565b60015b610673576105ff611499565b806308c379a00361064957506106136114f0565b8061061e575061064b565b6000805160206119398339815191528160405161063b91906116ba565b60405180910390a15061071c565b505b600080516020611939833981519152604051610666906116de565b60405180910390a161071c565b6040518060800160405280848152602001838152602001600115158152602001604051806040016040528060048152602001630a0f2e8d60e31b8152508152508585806106bf90611611565b965060ff16815181106106d4576106d4611630565b60200260200101819052507f14291c3647547e7abe3197b5c24b2b24317b6b49fde545229aa990e119915cac8383604051610710929190611702565b60405180910390a15050505b60025460405163b2ee2f0160e01b8152600481018690526001600160a01b039091169063b2ee2f01906024016040805180830381865afa925050508015610780575060408051601f3d908101601f1916820190925261077d91810190611726565b60015b6108005761078c611499565b806308c379a0036107d657506107a06114f0565b806107ab57506107d8565b600080516020611939833981519152816040516107c8919061174a565b60405180910390a1506108b0565b505b6000805160206119398339815191526040516107f390611776565b60405180910390a16108b0565b60405180608001604052808381526020018281526020016001151581526020016040518060400160405280600c81526020016b0556e697377617020545741560a41b81525081525084848061085490611611565b955060ff168151811061086957610869611630565b60200260200101819052507f14291c3647547e7abe3197b5c24b2b24317b6b49fde545229aa990e119915cac82826040516108a59291906117a2565b60405180910390a150505b60028160ff16101561091f5760405162461bcd60e51b815260206004820152602d60248201527f4f7261636c6541676772656761746f723a20496e73756666696369656e74206f60448201526c7261636c6520736f757263657360981b60648201526084015b60405180910390fd5b600061092b8383610bd1565b805160808083015160608085015160a08601516040805196875260ff9094166020870152928501529015159083015291925086917fa45624e8e42e14c08dfebd5af1e4696568e4cf34856144749549e4d153805103910160405180910390a2949350505050565b6000606060006109a184610358565b90508060a00151610a3357610bb8816060015111156109da576040518060800160405280604a81526020016119ab604a91399150610a46565b610e108160200151426109ed91906113e7565b1115610a13576040518060800160405280604181526020016118f8604191399150610a46565b604051806060016040528060268152602001611985602691399150610a46565b6040518060200160405280600081525091505b51939092509050565b6000805460405163b2ee2f0160e01b815260048101849052829182918291829182916001600160a01b03169063b2ee2f0190602401606060405180830381865afa925050508015610abd575060408051601f3d908101601f19168201909252610aba91810190611451565b60015b610aca5760009250610ad4565b5090965060019350505b60015460405163b2ee2f0160e01b8152600481018990526001600160a01b039091169063b2ee2f0190602401606060405180830381865afa925050508015610b39575060408051601f3d908101601f19168201909252610b369181019061167f565b60015b610b465760009150610b50565b5090955060019250505b60025460405163b2ee2f0160e01b8152600481018990526001600160a01b039091169063b2ee2f01906024016040805180830381865afa925050508015610bb4575060408051601f3d908101601f19168201909252610bb191810190611726565b60015b610bc057506000610bc8565b509350600190505b91939550919395565b610c166040518060e0016040528060008152602001600081526020016000815260200160008152602001600060ff168152602001600015158152602001606081525090565b60028260ff161015610c745760405162461bcd60e51b815260206004820152602160248201527f4f7261636c6541676772656761746f723a20546f6f2066657720736f757263656044820152607360f81b6064820152608401610916565b60008260ff1667ffffffffffffffff811115610c9257610c9261143b565b604051908082528060200260200182016040528015610cbb578160200160208202803683370190505b50905060008360ff1667ffffffffffffffff811115610cdc57610cdc61143b565b604051908082528060200260200182016040528015610d05578160200160208202803683370190505b50905060008460ff1667ffffffffffffffff811115610d2657610d2661143b565b604051908082528060200260200182016040528015610d5957816020015b6060815260200190600190039081610d445790505b50905060005b8560ff168160ff161015610e4557868160ff1681518110610d8257610d82611630565b602002602001015160000151848260ff1681518110610da357610da3611630565b602002602001018181525050868160ff1681518110610dc457610dc4611630565b602002602001015160200151838260ff1681518110610de557610de5611630565b602002602001018181525050868160ff1681518110610e0657610e06611630565b602002602001015160600151828260ff1681518110610e2757610e27611630565b60200260200101819052508080610e3d90611611565b915050610d5f565b5060018560ff161115610e6b57610e6b836000610e636001896117ce565b60ff166110db565b6000610e786002876117e7565b60ff16600003610efa57600284610e8f8289611809565b60ff1681518110610ea257610ea2611630565b602002602001015185600160028a610eba9190611809565b610ec491906117ce565b60ff1681518110610ed757610ed7611630565b6020026020010151610ee9919061182b565b610ef39190611427565b9050610f24565b83610f06600288611809565b60ff1681518110610f1957610f19611630565b602002602001015190505b600084600081518110610f3957610f39611630565b60200260200101519050600085600189610f5391906117ce565b60ff1681518110610f6657610f66611630565b602002602001015190506000838383610f7f91906113e7565b610f8b906127106113fa565b610f959190611427565b905060006127108210610fa9576000610fb5565b610fb5826127106113e7565b9050612710610fc58260646113fa565b610fcf9190611427565b9050600087600081518110610fe657610fe6611630565b602002602001015190506000600190505b8b60ff168160ff16101561105b5781898260ff168151811061101b5761101b611630565b6020026020010151101561104957888160ff168151811061103e5761103e611630565b602002602001015191505b8061105381611611565b915050610ff7565b506001610bb884111561106c575060005b610e1061107983426113e7565b1115611083575060005b6032831015611090575060005b6040518060e001604052808881526020018381526020018481526020018581526020018d60ff1681526020018215158152602001898152509a50505050505050505050505b92915050565b8082126110e757505050565b818160008560026110f8858561183e565b6111029190611865565b61110c9087611893565b8151811061111c5761111c611630565b602002602001015190505b81831361122b575b8086848151811061114257611142611630565b60200260200101511015611162578261115a816118bb565b93505061112f565b85828151811061117457611174611630565b6020026020010151811015611195578161118d816118da565b925050611162565b818313611226578582815181106111ae576111ae611630565b60200260200101518684815181106111c8576111c8611630565b60200260200101518785815181106111e2576111e2611630565b602002602001018885815181106111fb576111fb611630565b60209081029190910101919091525282611214816118bb565b9350508180611222906118da565b9250505b611127565b8185121561123e5761123e8686846110db565b83831215611251576112518684866110db565b505050505050565b60008060006060848603121561126e57600080fd5b505081359360208301359350604090920135919050565b6000815180845260005b818110156112ab5760208185018101518683018201520161128f565b506000602082860101526020601f19601f83011685010191505092915050565b82151581526040602082015260006112e66040830184611285565b949350505050565b60006020828403121561130057600080fd5b5035919050565b600060208083526101008301845182850152818501516040850152604085015160608501526060850151608085015260ff60808601511660a085015260a0850151151560c085015260c085015160e08086015281815180845261012093508387019150838160051b8801019350848301925060005b818110156113ab5761011f19888603018352611399858551611285565b9450928501929185019160010161137c565b5092979650505050505050565b8281526040602082015260006112e66040830184611285565b634e487b7160e01b600052601160045260246000fd5b818103818111156110d5576110d56113d1565b80820281158282048414176110d5576110d56113d1565b634e487b7160e01b600052601260045260246000fd5b60008261143657611436611411565b500490565b634e487b7160e01b600052604160045260246000fd5b60008060006060848603121561146657600080fd5b8351925060208401519150604084015169ffffffffffffffffffff8116811461148e57600080fd5b809150509250925092565b600060033d11156114b25760046000803e5060005160e01c5b90565b601f8201601f1916810167ffffffffffffffff811182821017156114e957634e487b7160e01b600052604160045260246000fd5b6040525050565b600060443d10156114fe5790565b6040516003193d81016004833e81513d67ffffffffffffffff816024840111818411171561152e57505050505090565b82850191508151818111156115465750505050505090565b843d87010160208285010111156115605750505050505090565b61156f602082860101876114b5565b509095945050505050565b6040815260006115a3604083016009815268436861696e6c696e6b60b81b602082015260400190565b82810360208401526112e68185611285565b6040815260006115de604083016009815268436861696e6c696e6b60b81b602082015260400190565b828103602084015261160a81600d81526c2ab735b737bbb71032b93937b960991b602082015260400190565b9392505050565b600060ff821660ff8103611627576116276113d1565b60010192915050565b634e487b7160e01b600052603260045260246000fd5b60608152600061166f606083016009815268436861696e6c696e6b60b81b602082015260400190565b6020830194909452506040015290565b60008060006060848603121561169457600080fd5b8351925060208401519150604084015167ffffffffffffffff8116811461148e57600080fd5b6040815260006115a36040830160048152630a0f2e8d60e31b602082015260400190565b6040815260006115de6040830160048152630a0f2e8d60e31b602082015260400190565b60608152600061166f6060830160048152630a0f2e8d60e31b602082015260400190565b6000806040838503121561173957600080fd5b505080516020909101519092909150565b6040815260006115a360408301600c81526b0556e697377617020545741560a41b602082015260400190565b6040815260006115de60408301600c81526b0556e697377617020545741560a41b602082015260400190565b60608152600061166f60608301600c81526b0556e697377617020545741560a41b602082015260400190565b60ff82811682821603908111156110d5576110d56113d1565b600060ff8316806117fa576117fa611411565b8060ff84160691505092915050565b600060ff83168061181c5761181c611411565b8060ff84160491505092915050565b808201808211156110d5576110d56113d1565b818103600083128015838313168383128216171561185e5761185e6113d1565b5092915050565b60008261187457611874611411565b600160ff1b82146000198414161561188e5761188e6113d1565b500590565b80820182811260008312801582168215821617156118b3576118b36113d1565b505092915050565b60006001600160ff1b0182016118d3576118d36113d1565b5060010190565b6000600160ff1b82016118ef576118ef6113d1565b50600019019056fe5741524e494e473a204f7261636c652064617461207374616c65202d207072696365206d6179206e6f74207265666c6563742063757272656e74206d61726b6574bd6a47a0fc1791b697df0534a73d88a501878f1f79b24d22a35d891ea2c34e294f7261636c65206461746120756e6865616c746879202d20636f6e666c696374696e67206f72207374616c655741524e494e473a204c6f7720636f6e666964656e636520696e206f7261636c6520646174615741524e494e473a204f7261636c6520736f757263657320636f6e666c696374203e333025202d207573696e67206d656469616e2077697468204849474820554e4345525441494e5459436c61696d6564207072696365206465766961746573203e3330252066726f6d206f7261636c6520636f6e73656e7375735072696365207665726966696564206279206f7261636c6520636f6e73656e737573a2646970667358221220616030b606555226ce782fe2d84e5bf2cb63d3034ee14c26d60eeee16f22a1ce64736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061009e5760003560e01c80639c3feeb7116100665780639c3feeb71461016a5780639d7f7e8614610195578063bdbde1f41461019e578063d8a0a352146101a7578063f98d06f0146101ba57600080fd5b806301dee057146100a35780631fde7f26146100cd57806327d69475146100ed5780632ee2f1281461010e5780639a321e3d14610124575b600080fd5b6100b66100b1366004611259565b6101cd565b6040516100c49291906112cb565b60405180910390f35b6100e06100db3660046112ee565b610358565b6040516100c49190611307565b6101006100fb3660046112ee565b610992565b6040516100c49291906113b8565b610116600281565b6040519081526020016100c4565b6101376101323660046112ee565b610a4f565b604080519687526020870195909552938501929092521515606084015215156080830152151560a082015260c0016100c4565b60005461017d906001600160a01b031681565b6040516001600160a01b0390911681526020016100c4565b610116610e1081565b610116610bb881565b60025461017d906001600160a01b031681565b60015461017d906001600160a01b031681565b6000606060006101dc86610358565b90506000816000015186116102125781516101f787826113e7565b610203906127106113fa565b61020d9190611427565b610234565b815161021e81886113e7565b61022a906127106113fa565b6102349190611427565b9050610bb88111156102665760006040518060600160405280603181526020016119f560319139935093505050610350565b8160a001516102955760006040518060600160405280602c8152602001611959602c9139935093505050610350565b428511156102e05760006040518060400160405280601b81526020017f436c61696d65642074696d657374616d7020696e206675747572650000000000815250935093505050610350565b610e106102ed86426113e7565b111561032e5760006040518060400160405280601581526020017410db185a5b5959081c1c9a58d9481d1bdbc81bdb19605a1b815250935093505050610350565b6001604051806060016040528060228152602001611a26602291399350935050505b935093915050565b61039d6040518060e0016040528060008152602001600081526020016000815260200160008152602001600060ff168152602001600015158152602001606081525090565b60408051600380825260808201909252600091816020015b6103e260405180608001604052806000815260200160008152602001600015158152602001606081525090565b8152602001906001900390816103b5579050506000805460405163b2ee2f0160e01b81526004810187905292935090916001600160a01b039091169063b2ee2f0190602401606060405180830381865afa925050508015610460575060408051601f3d908101601f1916820190925261045d91810190611451565b60015b6104e05761046c611499565b806308c379a0036104b657506104806114f0565b8061048b57506104b8565b600080516020611939833981519152816040516104a8919061157a565b60405180910390a15061058e565b505b6000805160206119398339815191526040516104d3906115b5565b60405180910390a161058e565b604051806080016040528084815260200183815260200160011515815260200160405180604001604052806009815260200168436861696e6c696e6b60b81b81525081525085858061053190611611565b965060ff168151811061054657610546611630565b60200260200101819052507f14291c3647547e7abe3197b5c24b2b24317b6b49fde545229aa990e119915cac8383604051610582929190611646565b60405180910390a15050505b60015460405163b2ee2f0160e01b8152600481018690526001600160a01b039091169063b2ee2f0190602401606060405180830381865afa9250505080156105f3575060408051601f3d908101601f191682019092526105f09181019061167f565b60015b610673576105ff611499565b806308c379a00361064957506106136114f0565b8061061e575061064b565b6000805160206119398339815191528160405161063b91906116ba565b60405180910390a15061071c565b505b600080516020611939833981519152604051610666906116de565b60405180910390a161071c565b6040518060800160405280848152602001838152602001600115158152602001604051806040016040528060048152602001630a0f2e8d60e31b8152508152508585806106bf90611611565b965060ff16815181106106d4576106d4611630565b60200260200101819052507f14291c3647547e7abe3197b5c24b2b24317b6b49fde545229aa990e119915cac8383604051610710929190611702565b60405180910390a15050505b60025460405163b2ee2f0160e01b8152600481018690526001600160a01b039091169063b2ee2f01906024016040805180830381865afa925050508015610780575060408051601f3d908101601f1916820190925261077d91810190611726565b60015b6108005761078c611499565b806308c379a0036107d657506107a06114f0565b806107ab57506107d8565b600080516020611939833981519152816040516107c8919061174a565b60405180910390a1506108b0565b505b6000805160206119398339815191526040516107f390611776565b60405180910390a16108b0565b60405180608001604052808381526020018281526020016001151581526020016040518060400160405280600c81526020016b0556e697377617020545741560a41b81525081525084848061085490611611565b955060ff168151811061086957610869611630565b60200260200101819052507f14291c3647547e7abe3197b5c24b2b24317b6b49fde545229aa990e119915cac82826040516108a59291906117a2565b60405180910390a150505b60028160ff16101561091f5760405162461bcd60e51b815260206004820152602d60248201527f4f7261636c6541676772656761746f723a20496e73756666696369656e74206f60448201526c7261636c6520736f757263657360981b60648201526084015b60405180910390fd5b600061092b8383610bd1565b805160808083015160608085015160a08601516040805196875260ff9094166020870152928501529015159083015291925086917fa45624e8e42e14c08dfebd5af1e4696568e4cf34856144749549e4d153805103910160405180910390a2949350505050565b6000606060006109a184610358565b90508060a00151610a3357610bb8816060015111156109da576040518060800160405280604a81526020016119ab604a91399150610a46565b610e108160200151426109ed91906113e7565b1115610a13576040518060800160405280604181526020016118f8604191399150610a46565b604051806060016040528060268152602001611985602691399150610a46565b6040518060200160405280600081525091505b51939092509050565b6000805460405163b2ee2f0160e01b815260048101849052829182918291829182916001600160a01b03169063b2ee2f0190602401606060405180830381865afa925050508015610abd575060408051601f3d908101601f19168201909252610aba91810190611451565b60015b610aca5760009250610ad4565b5090965060019350505b60015460405163b2ee2f0160e01b8152600481018990526001600160a01b039091169063b2ee2f0190602401606060405180830381865afa925050508015610b39575060408051601f3d908101601f19168201909252610b369181019061167f565b60015b610b465760009150610b50565b5090955060019250505b60025460405163b2ee2f0160e01b8152600481018990526001600160a01b039091169063b2ee2f01906024016040805180830381865afa925050508015610bb4575060408051601f3d908101601f19168201909252610bb191810190611726565b60015b610bc057506000610bc8565b509350600190505b91939550919395565b610c166040518060e0016040528060008152602001600081526020016000815260200160008152602001600060ff168152602001600015158152602001606081525090565b60028260ff161015610c745760405162461bcd60e51b815260206004820152602160248201527f4f7261636c6541676772656761746f723a20546f6f2066657720736f757263656044820152607360f81b6064820152608401610916565b60008260ff1667ffffffffffffffff811115610c9257610c9261143b565b604051908082528060200260200182016040528015610cbb578160200160208202803683370190505b50905060008360ff1667ffffffffffffffff811115610cdc57610cdc61143b565b604051908082528060200260200182016040528015610d05578160200160208202803683370190505b50905060008460ff1667ffffffffffffffff811115610d2657610d2661143b565b604051908082528060200260200182016040528015610d5957816020015b6060815260200190600190039081610d445790505b50905060005b8560ff168160ff161015610e4557868160ff1681518110610d8257610d82611630565b602002602001015160000151848260ff1681518110610da357610da3611630565b602002602001018181525050868160ff1681518110610dc457610dc4611630565b602002602001015160200151838260ff1681518110610de557610de5611630565b602002602001018181525050868160ff1681518110610e0657610e06611630565b602002602001015160600151828260ff1681518110610e2757610e27611630565b60200260200101819052508080610e3d90611611565b915050610d5f565b5060018560ff161115610e6b57610e6b836000610e636001896117ce565b60ff166110db565b6000610e786002876117e7565b60ff16600003610efa57600284610e8f8289611809565b60ff1681518110610ea257610ea2611630565b602002602001015185600160028a610eba9190611809565b610ec491906117ce565b60ff1681518110610ed757610ed7611630565b6020026020010151610ee9919061182b565b610ef39190611427565b9050610f24565b83610f06600288611809565b60ff1681518110610f1957610f19611630565b602002602001015190505b600084600081518110610f3957610f39611630565b60200260200101519050600085600189610f5391906117ce565b60ff1681518110610f6657610f66611630565b602002602001015190506000838383610f7f91906113e7565b610f8b906127106113fa565b610f959190611427565b905060006127108210610fa9576000610fb5565b610fb5826127106113e7565b9050612710610fc58260646113fa565b610fcf9190611427565b9050600087600081518110610fe657610fe6611630565b602002602001015190506000600190505b8b60ff168160ff16101561105b5781898260ff168151811061101b5761101b611630565b6020026020010151101561104957888160ff168151811061103e5761103e611630565b602002602001015191505b8061105381611611565b915050610ff7565b506001610bb884111561106c575060005b610e1061107983426113e7565b1115611083575060005b6032831015611090575060005b6040518060e001604052808881526020018381526020018481526020018581526020018d60ff1681526020018215158152602001898152509a50505050505050505050505b92915050565b8082126110e757505050565b818160008560026110f8858561183e565b6111029190611865565b61110c9087611893565b8151811061111c5761111c611630565b602002602001015190505b81831361122b575b8086848151811061114257611142611630565b60200260200101511015611162578261115a816118bb565b93505061112f565b85828151811061117457611174611630565b6020026020010151811015611195578161118d816118da565b925050611162565b818313611226578582815181106111ae576111ae611630565b60200260200101518684815181106111c8576111c8611630565b60200260200101518785815181106111e2576111e2611630565b602002602001018885815181106111fb576111fb611630565b60209081029190910101919091525282611214816118bb565b9350508180611222906118da565b9250505b611127565b8185121561123e5761123e8686846110db565b83831215611251576112518684866110db565b505050505050565b60008060006060848603121561126e57600080fd5b505081359360208301359350604090920135919050565b6000815180845260005b818110156112ab5760208185018101518683018201520161128f565b506000602082860101526020601f19601f83011685010191505092915050565b82151581526040602082015260006112e66040830184611285565b949350505050565b60006020828403121561130057600080fd5b5035919050565b600060208083526101008301845182850152818501516040850152604085015160608501526060850151608085015260ff60808601511660a085015260a0850151151560c085015260c085015160e08086015281815180845261012093508387019150838160051b8801019350848301925060005b818110156113ab5761011f19888603018352611399858551611285565b9450928501929185019160010161137c565b5092979650505050505050565b8281526040602082015260006112e66040830184611285565b634e487b7160e01b600052601160045260246000fd5b818103818111156110d5576110d56113d1565b80820281158282048414176110d5576110d56113d1565b634e487b7160e01b600052601260045260246000fd5b60008261143657611436611411565b500490565b634e487b7160e01b600052604160045260246000fd5b60008060006060848603121561146657600080fd5b8351925060208401519150604084015169ffffffffffffffffffff8116811461148e57600080fd5b809150509250925092565b600060033d11156114b25760046000803e5060005160e01c5b90565b601f8201601f1916810167ffffffffffffffff811182821017156114e957634e487b7160e01b600052604160045260246000fd5b6040525050565b600060443d10156114fe5790565b6040516003193d81016004833e81513d67ffffffffffffffff816024840111818411171561152e57505050505090565b82850191508151818111156115465750505050505090565b843d87010160208285010111156115605750505050505090565b61156f602082860101876114b5565b509095945050505050565b6040815260006115a3604083016009815268436861696e6c696e6b60b81b602082015260400190565b82810360208401526112e68185611285565b6040815260006115de604083016009815268436861696e6c696e6b60b81b602082015260400190565b828103602084015261160a81600d81526c2ab735b737bbb71032b93937b960991b602082015260400190565b9392505050565b600060ff821660ff8103611627576116276113d1565b60010192915050565b634e487b7160e01b600052603260045260246000fd5b60608152600061166f606083016009815268436861696e6c696e6b60b81b602082015260400190565b6020830194909452506040015290565b60008060006060848603121561169457600080fd5b8351925060208401519150604084015167ffffffffffffffff8116811461148e57600080fd5b6040815260006115a36040830160048152630a0f2e8d60e31b602082015260400190565b6040815260006115de6040830160048152630a0f2e8d60e31b602082015260400190565b60608152600061166f6060830160048152630a0f2e8d60e31b602082015260400190565b6000806040838503121561173957600080fd5b505080516020909101519092909150565b6040815260006115a360408301600c81526b0556e697377617020545741560a41b602082015260400190565b6040815260006115de60408301600c81526b0556e697377617020545741560a41b602082015260400190565b60608152600061166f60608301600c81526b0556e697377617020545741560a41b602082015260400190565b60ff82811682821603908111156110d5576110d56113d1565b600060ff8316806117fa576117fa611411565b8060ff84160691505092915050565b600060ff83168061181c5761181c611411565b8060ff84160491505092915050565b808201808211156110d5576110d56113d1565b818103600083128015838313168383128216171561185e5761185e6113d1565b5092915050565b60008261187457611874611411565b600160ff1b82146000198414161561188e5761188e6113d1565b500590565b80820182811260008312801582168215821617156118b3576118b36113d1565b505092915050565b60006001600160ff1b0182016118d3576118d36113d1565b5060010190565b6000600160ff1b82016118ef576118ef6113d1565b50600019019056fe5741524e494e473a204f7261636c652064617461207374616c65202d207072696365206d6179206e6f74207265666c6563742063757272656e74206d61726b6574bd6a47a0fc1791b697df0534a73d88a501878f1f79b24d22a35d891ea2c34e294f7261636c65206461746120756e6865616c746879202d20636f6e666c696374696e67206f72207374616c655741524e494e473a204c6f7720636f6e666964656e636520696e206f7261636c6520646174615741524e494e473a204f7261636c6520736f757263657320636f6e666c696374203e333025202d207573696e67206d656469616e2077697468204849474820554e4345525441494e5459436c61696d6564207072696365206465766961746573203e3330252066726f6d206f7261636c6520636f6e73656e7375735072696365207665726966696564206279206f7261636c6520636f6e73656e737573a2646970667358221220616030b606555226ce782fe2d84e5bf2cb63d3034ee14c26d60eeee16f22a1ce64736f6c63430008140033",
  "devdoc": {
    "details": "Handles: conflicting values, staleness, 30% manipulation, missing updatesByzantine-resistant: 2/3 honest oracles ensure correct median price",
    "kind": "dev",
    "methods": {
      "getAggregatedPrice(bytes32)": {
        "details": "Handles all 4 adversarial conditions from hackathon spec",
        "params": {
          "pairId": "Asset pair (e.g., keccak256(\"ETH/USD\"))"
        },
        "returns": {
          "_0": "Aggregated price data with health metrics"
        }
      },
      "getEmergencyPrice(bytes32)": {
        "details": "Only use when system must proceed despite oracle issues",
        "params": {
          "pairId": "Asset pair"
        },
        "returns": {
          "price": "Median price (may be unreliable)",
          "warning": "Explicit warning message"
        }
      },
      "getIndividualPrices(bytes32)": {
        "details": "Useful for debugging and showing which oracle is outlier",
        "params": {
          "pairId": "Asset pair"
        },
        "returns": {
          "chainlinkPrice": "Price from Chainlink",
          "chainlinkSuccess": "True if Chainlink succeeded",
          "pythPrice": "Price from Pyth",
          "pythSuccess": "True if Pyth succeeded",
          "uniswapPrice": "Price from Uniswap TWAP",
          "uniswapSuccess": "True if Uniswap succeeded"
        }
      },
      "verifyClaimedPrice(bytes32,uint256,uint256)": {
        "details": "Used in dispute resolution - checks against all 4 adversarial conditions",
        "params": {
          "claimTimestamp": "When price was claimed",
          "claimedPrice": "Price submitted by prover",
          "pairId": "Asset pair"
        },
        "returns": {
          "isValid": "True if claim passes verification",
          "reason": "Explanation of result"
        }
      }
    },
    "title": "OracleAggregator",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getAggregatedPrice(bytes32)": {
        "notice": "Get aggregated price from all oracle sources"
      },
      "getEmergencyPrice(bytes32)": {
        "notice": "Emergency: Get price even if unhealthy (with explicit warnings)"
      },
      "getIndividualPrices(bytes32)": {
        "notice": "Get individual oracle prices for transparency"
      },
      "verifyClaimedPrice(bytes32,uint256,uint256)": {
        "notice": "Verify if a claimed price is reasonable given current oracle state"
      }
    },
    "notice": "Aggregates 3 oracle sources with Byzantine fault tolerance",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3515,
        "contract": "contracts/oracles/OracleAggregator.sol:OracleAggregator",
        "label": "chainlink",
        "offset": 0,
        "slot": "0",
        "type": "t_contract(ChainlinkOracleAdapter)3013"
      },
      {
        "astId": 3518,
        "contract": "contracts/oracles/OracleAggregator.sol:OracleAggregator",
        "label": "pyth",
        "offset": 0,
        "slot": "1",
        "type": "t_contract(PythOracleAdapter)4839"
      },
      {
        "astId": 3521,
        "contract": "contracts/oracles/OracleAggregator.sol:OracleAggregator",
        "label": "uniswapTWAP",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(UniswapV3TWAPAdapter)5816"
      }
    ],
    "types": {
      "t_contract(ChainlinkOracleAdapter)3013": {
        "encoding": "inplace",
        "label": "contract ChainlinkOracleAdapter",
        "numberOfBytes": "20"
      },
      "t_contract(PythOracleAdapter)4839": {
        "encoding": "inplace",
        "label": "contract PythOracleAdapter",
        "numberOfBytes": "20"
      },
      "t_contract(UniswapV3TWAPAdapter)5816": {
        "encoding": "inplace",
        "label": "contract UniswapV3TWAPAdapter",
        "numberOfBytes": "20"
      }
    }
  }
}